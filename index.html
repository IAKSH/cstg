<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"iaksh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hello world!">
<meta property="og:url" content="https://iaksh.github.io/index.html">
<meta property="og:site_name" content="Hello world!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="IAKSH">
<meta property="article:tag" content="IAKSH">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://iaksh.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hello world!</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hello world!</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/10/04/%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/04/%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">记忆化递归和动态规划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-04 16:33:32 / 修改时间：16:34:29" itemprop="dateCreated datePublished" datetime="2022-10-04T16:33:32+08:00">2022-10-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我是想记录一下<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">这道题</a>。</p>
<h1 id="爬楼梯问题的递归解法"><a href="#爬楼梯问题的递归解法" class="headerlink" title="爬楼梯问题的递归解法"></a>爬楼梯问题的递归解法</h1><p>原题是这样的：</p>
<blockquote>
<p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
</blockquote>
<p>很容易想到这样的树状图结构：</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xAoMuR"><img src="https://img-blog.csdnimg.cn/img_convert/40cc5d547695b6af0177f279302004d0.png" alt="xAoMuR.png"></a></p>
<p>利用递归算法进行实现应该是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归入口</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">climbStairs</span>(n<span class="number">-1</span>) + <span class="built_in">climbStairs</span>(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看似天衣无缝，然而…</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xA5fzj"><img src="https://img-blog.csdnimg.cn/img_convert/dece0e8f4c2c0caa77ddf41a290c4ea2.png" alt="xA5fzj.png"></a></p>
<p>其实仔细观察上述树状图，不难发现该算法的时间复杂度是$O(2^n)$，每一层递归的复杂度是上一层的两倍，这样的效率可以说是糟糕的了。</p>
<p>有没有方法可以优化这样的递归？</p>
<h1 id="记忆化递归"><a href="#记忆化递归" class="headerlink" title="记忆化递归"></a>记忆化递归</h1><p>”记忆化递归“，这个算法有很多名字，比如“递归树的剪枝”，“备忘录递归”…… 其核心思想就是去除递归过程中不必要的重复计算，以提高算法的效率。</p>
<p>那么我们要去除的”不必要的重复计算“在哪里呢，请看：</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xAolHx"><img src="https://img-blog.csdnimg.cn/img_convert/ac22a313c6ec2c7b4517d105e98109ea.png" alt="xAolHx.png"></a></p>
<p>以同一数字展开的树状图当然是一样的，如果我们能够保存第一次计算时的结果，在以后遇到同样数字时直接使用先前计算得到的结果，就能给树状图”剪枝”，也就能消除“不必要的重复“了。</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xAo3E6"><img src="https://img-blog.csdnimg.cn/img_convert/9e31647e74a390e3d554e0099e5533d4.png" alt="xAo3E6.png"></a></p>
<p>上述思路中，我们实际上需要储存的是树状图中的被展开数与其最终结果之间的关系，也就是键值对，那么哈希表就是最好的选择。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> item = umap.<span class="built_in">find</span>(n);</span><br><span class="line"><span class="keyword">if</span>(item != umap.<span class="built_in">end</span>()) <span class="keyword">return</span> item-&gt;second;</span><br></pre></td></tr></table></figure>
<p>稍微写一个类似单元测试的框架，整体的代码是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 时间优化，查询并尝试利用之前已经计算过的爬n个楼梯的方法数</span></span><br><span class="line">        <span class="keyword">auto</span> item = umap.<span class="built_in">find</span>(n);</span><br><span class="line">        <span class="keyword">if</span>(item != umap.<span class="built_in">end</span>()) <span class="keyword">return</span> item-&gt;second;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归入口，集成了时间优化的记录</span></span><br><span class="line">        <span class="keyword">auto</span> buffer = <span class="built_in">climbStairs</span>(n - <span class="number">1</span>) + <span class="built_in">climbStairs</span>(n - <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 时间优化，记录当前计算的爬楼梯数n与其方法数的对应关系到哈希表</span></span><br><span class="line">        umap.<span class="built_in">insert</span>(&#123; n, buffer &#125;);</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Solution s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> target)</span> </span>&#123; <span class="keyword">return</span> s.<span class="built_in">climbStairs</span>(n) == target; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::array&lt;std::array&lt;<span class="type">int</span>, 2&gt;, 7&gt; tests&#123; <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">13</span>, <span class="number">7</span>, <span class="number">21</span>, <span class="number">8</span>, <span class="number">34</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; item : tests)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">test</span>(item.<span class="built_in">at</span>(<span class="number">0</span>), item.<span class="built_in">at</span>(<span class="number">1</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;failed on test(&quot;</span> &lt;&lt; item.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; <span class="string">&quot;),it should be &quot;</span> &lt;&lt; item.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;,but actually &quot;</span> &lt;&lt; s.<span class="built_in">climbStairs</span>(item.<span class="built_in">at</span>(<span class="number">0</span>)) &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;PASSED\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时代码已经能够在力扣上通过，本地Linux上测试的结果表明，当n=45时，记忆化递归平均用时0.0016s，而原始递归平均耗时为4.618s，仅仅几行代码将效率提升了接近3000倍。</p>
<p>但是这样的提升也不是毫无代价的，为了实现记忆化，我们使用了一个哈希表，而哈希表恰好就是个拿空间换时间的主，难以避免的，记忆化递归也是在用空间换取时间。不过在大多数情况下，和节省的时间相比，多耗费的那点内存根本不值一提。</p>
<p><del>后记：本来想拓展到动态规划的，但是好像超出我目前的能力范围了，等我学会了再写吧。</del></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1AB4y1w7eT">https://www.bilibili.com/video/BV1AB4y1w7eT</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/solution/yuan-lai-hui-pa-lou-ti-de-zheng-que-zi-s-pjez/">猿来绘-爬楼梯的正确姿势（拥抱递归）-70. 爬楼梯 - 爬楼梯 - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013309870/article/details/75193592">算法-动态规划 Dynamic Programming—从菜鸟到老鸟<em>HankingHu的博客-CSDN博客</em>动态规划</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/10/04/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/04/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">快慢指针算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-04 15:34:22 / 修改时间：15:36:13" itemprop="dateCreated datePublished" datetime="2022-10-04T15:34:22+08:00">2022-10-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><del>平衡二叉树好像有点难，我来写个简单的摸摸鱼（</del></p>
<h1 id="环形链表问题"><a href="#环形链表问题" class="headerlink" title="环形链表问题"></a>环形链表问题</h1><p>Leetcode上有<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">这样一道题</a></p>
<blockquote>
<p>给你一个链表的头节点 head ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
</blockquote>
<p>只让判断是否有环，非常简单，根据之前的备忘录算法我很快写出了这串代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        std::unordered_map&lt;ListNode*,<span class="type">int</span>&gt; mem;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mem.<span class="built_in">find</span>(head) != mem.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            mem.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;ListNode*,<span class="type">int</span>&gt;(head,head-&gt;val));</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>非常优雅，但…</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xm3a34"><img src="https://img-blog.csdnimg.cn/img_convert/7f642122d7d69074c1dd06b38808ec0b.png" alt="xm3a34.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xm3YNT"><img src="https://img-blog.csdnimg.cn/img_convert/21dce248550383629dec746fd4e85b52.png" alt="xm3YNT.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xm3t4U"><img src="https://img-blog.csdnimg.cn/img_convert/19e547f9277c6e709f61091767fc9e41.png" alt="xm3t4U.png"></a></p>
<p>可以说是惨不忍睹了，虽知哈希表以空间换时间，但全盘皆输，着实令人大跌眼镜。</p>
<h2 id="快慢指针算法"><a href="#快慢指针算法" class="headerlink" title="快慢指针算法"></a>快慢指针算法</h2><p>又叫Floyd判圈法（弗洛伊德判圈法），简单地说就是在表的头部放置两个前进速度不同的指针，使他们同时出发，如果该表不是线性表，则前进速度快的指针会率先进入”循环圈“，慢指针紧随其后，使快指针追击慢指针。由于有速度差异，只要该”循环圈“存在，快指针在”循环圈“内运行若干周期后，总会追上慢指针，所以只要指针和慢指针相遇，我们就能认定该链表是环形链表。</p>
<p>基于以上理解，我们可以写出如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">2</span>;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count = <span class="number">2</span>;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                --count;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(slow == head) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>效果立竿见影</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xm3UCF"><img src="https://img-blog.csdnimg.cn/img_convert/ac1ad8672de95b6f019aebdc264b0667.png" alt="xm3UCF.png"></a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/09/16/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/16/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/" class="post-title-link" itemprop="url">哈希算法和哈希表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-16 23:36:34" itemprop="dateCreated datePublished" datetime="2022-09-16T23:36:34+08:00">2022-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-04 16:22:56" itemprop="dateModified" datetime="2022-10-04T16:22:56+08:00">2022-10-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章将会简单介绍几种常见的哈希算法，然后是C++或Java的标准库中哈希函数与哈希表的基本使用，最后将会提供一个使用C语言手搓FNV-1a算法的示例，以及使用它实现的哈希表。</p>
<p>这篇文章虽然内容不多，但前前后后，也是删删改改了好多天了，虽然内容还是不尽人意，但希望此文能为你提供一点帮助，不说理解哈希，至少能够使用吧。</p>
<p>不知道某位大佬会不会来看这篇文章，关于哈希表的部分我不是很拿得准，如果理解有误，请帮我指出。</p>
<h1 id="什么是哈希算法（散列算法）"><a href="#什么是哈希算法（散列算法）" class="headerlink" title="什么是哈希算法（散列算法）"></a>什么是哈希算法（散列算法）</h1><blockquote>
<p><strong>散列函数</strong>（英语：Hash function）又称<strong>散列算法</strong>、<strong>哈希函数</strong>，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0" title="函数">函数</a>将数据打乱混合，重新创建一个叫做<strong>散列值</strong>（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8#cite_note-1">[1]</a>好的散列函数在输入域中很少出现<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%95%A3%E5%88%97%E5%86%B2%E7%AA%81&action=edit&redlink=1" title="散列冲突（页面不存在）">散列冲突</a>。在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E8%A1%A8" title="散列表">散列表</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86" title="数据处理">数据处理</a>中，不抑制冲突来区别数据，会使得<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%B0%E5%BD%95&action=edit&redlink=1" title="数据库记录（页面不存在）">数据库记录</a>更难找到。</p>
<p>如今，散列算法也被用来加密存在数据库中的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC" title="密码">密码</a>（password）字符串，由于散列算法所计算出来的<strong>散列值（Hash Value）</strong>具有<strong>不可逆</strong>（无法逆向演算回原本的数值）的性质，因此可有效的保护密码。</p>
<p>——Wikipedia</p>
</blockquote>
<p>我个人认为散列是一种数学思想，或者说是一种思维方式，能被应用到任意的方面。</p>
<p>简单的说，哈希算法是一套映射，向它输入不同的数据就能获得不同的结果，比如无论算几次都有hash(A) &#x3D; a恒成立,而不可能有hash(B) &#x3D; a（前提是没有碰撞），而且你没办法从结果逆推出原来的数据。</p>
<h1 id="哈希算法有什么应用场景"><a href="#哈希算法有什么应用场景" class="headerlink" title="哈希算法有什么应用场景"></a>哈希算法有什么应用场景</h1><ol>
<li><p>安全加密：基于哈希算法的输出值与原始数据唯一对应且不可逆向，哈希值散乱分布不可预测这两个特性，哈希算法可以被应用于密码存储，数据加密等安全领域。</p>
</li>
<li><p>唯一标识：哈希算法的输入值可以是任意长度，输出值与原始数据唯一对应且不可逆向，所以哈希算法能被应用于文件校验领域，作为一个文件的”指纹“，成为它的唯一标识。</p>
</li>
<li><p>数据校验：哈希值有”散列“特征，即便原始数据只进行了细微的修改，依然会导致哈希值产生巨大的变化。由此，在安全加密和唯一标识的基础上，哈希算法还能被应用于数据校验。</p>
</li>
<li><p>散列函数：散列函数（哈希函数）是哈希表的基础，也是其最关键的部分，它直接决定了哈希表中发生碰撞（冲突）的概率和哈希表的性能。</p>
</li>
<li><p>数据分片和分布式：通过类似哈希表的结构，我们可以将一次数据索拆分并下发至不同的机器执行，以此实现分布式网络，提高运行效率甚至是解决单机根本无法进行的操作。</p>
</li>
</ol>
<h1 id="什么是哈希碰撞（哈希冲突）"><a href="#什么是哈希碰撞（哈希冲突）" class="headerlink" title="什么是哈希碰撞（哈希冲突）"></a>什么是哈希碰撞（哈希冲突）</h1><p>前文提到了“哈希算法获取数据的唯一对应哈希值”，这实际上需要建立在没有“哈希碰撞”的基础上。在理想情况下，我们向哈希函数输入两串数据，所返回哈希值一定不相同，但实际上，这样的说法并不成立。当不同的数据经过某种哈希算法获得了同一个哈希值，我们就称这时发生了“哈希碰撞”，就像是坐标系中的两个本应不相交的函数，随着X值的延伸，突然“碰撞”了，产生了至少一个交点。</p>
<p>哈希碰撞一旦发生，所谓的“密码学价值”也就得大打折扣了，但对于大多数哈希算法而言，碰撞虽无法避免，却也是难以发生的，在有限的范围内，我们可以近似地认为，哈希函数不会发生碰撞。</p>
<p>尽管如此，哈希碰撞依然带来了巨大的安全隐患，这种隐患不只是你从互联网上下载的文件的校验问题，它涉及到操作系统，企业服务器网络，甚至是金融体系的安全。</p>
<p>当然，数学家们也不是吃素的，早期的一些哈希算法被爆出漏洞后，不断的有一些新的算法出现，这些新算法的安全性极高，在短期，甚至是一段比较长的时期内几乎不会出现安全问题。</p>
<h1 id="常见的哈希算法"><a href="#常见的哈希算法" class="headerlink" title="常见的哈希算法"></a>常见的哈希算法</h1><p>实际上，哈希函数应该分为加密哈希函数和非加密哈希函数</p>
<blockquote>
<p>Every cryptographic hash function is a hash function. But not every hash function is a cryptographic hash.</p>
<p>A cryptographic hash function aims to guarantee a number of security properties. Most importantly that it’s hard to find collisions or pre-images and that the output appears random. (There are a few more properties, and “hard” has well defined bounds in this context, but that’s not important here.)</p>
<p>Non cryptographic hash functions just try to avoid collisions for non malicious input. Some aim to detect accidental changes in data (CRCs), others try to put objects into different buckets in a hash table with as few collisions as possible.</p>
<p>In exchange for weaker guarantees they are typically (much) faster.</p>
<p>I’d still call MD5 a cryptographic hash function, since it aimed to provide security. But it’s broken, and thus no longer usable as a cryptographic hash. On the other hand when you have a non cryptographic hash function, you can’t really call it “broken”, since it never tried to be secure in the first place.</p>
<p><a target="_blank" rel="noopener" href="https://security.stackexchange.com/a/11841">https://security.stackexchange.com/a/11841</a></p>
</blockquote>
<p>简单地说，非加密哈希函数只要求能够防御基本的恶意攻击，比较简单快速，而加密哈希函数则为了实现较高的安全性，不可逆性以及更加难以预测的哈希值分布而变得复杂。</p>
<p>我没有对这两个分类进行进一步的讨论，想要了解更多可以访问上面的连接。</p>
<p><em>到底怎样才能算是”常见“呢？这个问题很难回答…但我再这里列出了wiki上提到的部分以及我在搜集资料时见到比较多的算法。</em></p>
<p><em>另外，wiki上关于SHA-256等函数的碰撞情况是”无“，这显然是无稽之谈…我将他们全部改成“近似无”了。</em></p>
<table>
<thead>
<tr>
<th>算法名</th>
<th>碰撞情况</th>
<th>简述</th>
</tr>
</thead>
<tbody><tr>
<td>HAVAL</td>
<td>有</td>
<td>比较现代化的哈希函数，哈希值长度可为256&#x2F;224&#x2F;192&#x2F;160&#x2F;128bit</td>
</tr>
<tr>
<td>MD2</td>
<td>大多数</td>
<td>诞生于1989年，哈希值长度固定为128bit，“MD”意为“Message Digest”，由于自身设计缺陷，MD2于2009年被证明“容易受到攻击”，并被OpenSSL等项目禁用。</td>
</tr>
<tr>
<td>MD4</td>
<td>有</td>
<td>诞生于1990年的麻省理工学院，哈希值长度固定为128bit，对后世的算法（如MD5，SHA系以及RIPEMD）有长远的影响，其变种算法”eD2k Hash“至今仍被广泛用于eDonkey网络的eD2k链接中。</td>
</tr>
<tr>
<td>MD5</td>
<td>有</td>
<td>公开于1992年，其哈希值长度固定为128bit，用于取代MD4算法，曾盛极一时，但先后在1996和2004被证明安全性堪忧，此后MD5被广泛认为并不适用于安全性认证。</td>
</tr>
<tr>
<td>PANAMA</td>
<td>有</td>
<td>公开于1998年，哈希值长度固定为256bit，密码性能良好，但先后在2001于2007年被证明安全性不足，后基本被SHA-3取代。</td>
</tr>
<tr>
<td>RadioGatún</td>
<td>近似无</td>
<td>PANAMA的一个变体，哈希值长度任意，公开于2006年。</td>
</tr>
<tr>
<td>RIPEMD</td>
<td>有</td>
<td>公开于1996年，是一个来自比利时鲁汶大学的研究小组的成果，以MD4为基础，但与SHA-1更类似。</td>
</tr>
<tr>
<td>RIPEMD-128&#x2F;256</td>
<td>近似无</td>
<td>RIPEMD算法的一个变种，虽然128bit的哈希值长度相较于原版并没有进步，但RIPEMD-128解决了哈希碰撞问题。另外，256bit的版本只在128bit版本（非原版）的基础上修改了初始参数和s-box，两者的强度理论上是没有区别的。</td>
</tr>
<tr>
<td>RIPEMD-160&#x2F;320</td>
<td>近似无</td>
<td>RIPEMD算法的又一个变种，相较于RIPEMD-128拥有更高的安全等级。同样的，320bit的版本也只是在160bit版本的基础上修改了初始参数和s-box，两者的强度理论上没有区别。</td>
</tr>
<tr>
<td>SHA-0</td>
<td>有</td>
<td>SHA家族的初代，SHA全写为”Secure Hash Algorithm”，由……美国国安局（NSA）设计，然后由美国国家标准与技术研究院（NIST）于1993年发布，但发布后又被NSA突然撤回。</td>
</tr>
<tr>
<td>SHA-1</td>
<td>有缺陷</td>
<td>MD5的继任者，发布于1995年，还是NSA设计，NIST发布，其哈希值长度固定为160bit。该算法于2005年被证明不够安全，2010年以来，越来越多的组织建议使用SHA-2或SHA-3替代SHA-1，但时至今日，SHA-1依然没用被完全弃用，尽管针对它的攻击手段早在2020年就已经成熟了。</td>
</tr>
<tr>
<td>SHA-256&#x2F;224</td>
<td>近似无</td>
<td>SHA-2的一部分，还是NSA，还是NIST。SHA-2发布于2001年，用于替代羸弱的SHA-1，包括6种算法标准：SHA-224，SHA-256（某种意义上的“明星”，是比特币使用的算法），SHA-384，SHA-512，SHA-512&#x2F;224，SHA-512&#x2F;256。就目前而言，SHA-2在理论上是安全的，它的碰撞可能性基本可以被看做是0。</td>
</tr>
<tr>
<td>SHA-512&#x2F;384</td>
<td>近似无</td>
<td>同上。</td>
</tr>
<tr>
<td>Tiger（2）-192&#x2F;160&#x2F;128</td>
<td>近似无</td>
<td>前身是诞生于1995年的Tiger算法，曾经有望纳入OpenPGP标准，但最后败给了RIPEMD-160算法。</td>
</tr>
<tr>
<td>WHIRLPOOL</td>
<td>近似无</td>
<td>公布于2000年，现已被国际标准化组织（ISO）和国际电工委员会（IEC）采用，做为ISO&#x2F;IEC 10118-3国际标准的一部分。其作者曾对外宣布自己”没有（也永远不会）申请专利“，该算可以免费地用于任何目的。</td>
</tr>
<tr>
<td>FNV-1a&#x2F;FNV-1</td>
<td>有</td>
<td>FNV算法诞生于1991年，其名称由三位设计者的名字拼接而成，该算法在保证快速的同时将冲突率限制在了相对合理的区间内，支持从32bit到1024bit的多种长度的哈希值输出，且其哈希值高度分散，非常适合处理网址，文本，文件名，IP地址等字符串。其最早版本FNV-0已被抛弃，更新的FNV-1和FNV-1a只在异或和乘法这两种运算的顺序上有差别。</td>
</tr>
</tbody></table>
<h1 id="C-和Java中预置的哈希函数和哈希表"><a href="#C-和Java中预置的哈希函数和哈希表" class="headerlink" title="C++和Java中预置的哈希函数和哈希表"></a>C++和Java中预置的哈希函数和哈希表</h1><ol>
<li>C++</li>
</ol>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ISO C++ 11标准及以后，标准库中提供了一个 std::hash&lt;T&gt;，返回参数的哈希值</span></span><br><span class="line"><span class="comment">// std::hash&lt;T&gt; 所使用的哈希算法是由具体编译器实现所决定的</span></span><br><span class="line"><span class="comment">// 对于老旧的编译器，std::hash&lt;T&gt; 所使用的算法很可能是已经被破解，不再安全的</span></span><br><span class="line"><span class="comment">// 下面是 std::hash&lt;T&gt; 的一个使用列，打印字符串“Hello world!“的哈希值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hashTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">    std::hash&lt;std::string&gt; hashFunction;</span><br><span class="line">    <span class="type">size_t</span> hashValue = <span class="built_in">hashFunction</span>(str);</span><br><span class="line">    std::cout &lt;&lt; hashValue &lt;&lt; std;:endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还有两个键值对数据结构，分别是 std::map&lt;T,T&gt; 和 std::unordered_map&lt;T,T&gt;</span></span><br><span class="line"><span class="comment">// 前者的内部存储方式为平衡二叉查找树（比如红黑树），后者是真正的哈希表</span></span><br><span class="line"><span class="comment">// std::map</span></span><br><span class="line">map&lt;std::string,<span class="type">int</span>&gt; nameAgeMap =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">&quot;Hatsune Miku&quot;</span>,<span class="number">15</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;ZUN&quot;</span>,<span class="number">45</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::map 的插入，如果下标不存在，则新建，若存在则修改。</span></span><br><span class="line">nameAgeMap[<span class="string">&quot;Linus&quot;</span>] = <span class="number">52</span>;</span><br><span class="line"><span class="comment">// 上述语法与下式等价</span></span><br><span class="line">nameAgeMap.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;std::string,<span class="type">int</span>&gt;(<span class="string">&quot;Linus&quot;</span>,<span class="number">52</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::map 的取值</span></span><br><span class="line"><span class="keyword">auto</span> buffer0 = nameAgeMap[<span class="string">&quot;Linus&quot;</span>];</span><br><span class="line"><span class="comment">// 也可以这样写</span></span><br><span class="line"><span class="keyword">auto</span> buffer1 = nameAgeMap.<span class="built_in">at</span>(<span class="string">&quot;Linus&quot;</span>);</span><br><span class="line"><span class="comment">// 需要注意的是，map.at() 只会尝试读取，若找不到则报错</span></span><br><span class="line"><span class="comment">// 而map[]找不到则会创建，只是值未设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// std::map 的查找</span></span><br><span class="line"><span class="keyword">auto</span> iter = nameAgeMap.<span class="built_in">find</span>(<span class="string">&quot;Linus&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(ite == nameAgeMap.<span class="built_in">end</span>()) <span class="built_in">abort</span>();</span><br><span class="line"><span class="keyword">auto</span> value = iter-&gt;second;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::map 的遍历</span></span><br><span class="line"><span class="comment">// 作为STL的一部分，std::map提供了迭代器，可供迭代器循环或增强for使用。</span></span><br><span class="line"><span class="comment">// 迭代器语法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> item = nameAgeMap.<span class="built_in">begin</span>();item != nameAgeMap.<span class="built_in">end</span>();item++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 增强for</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; item : nameAgeMap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::map 的清除</span></span><br><span class="line"><span class="comment">// 通常情况下使用 map.clear() 就好</span></span><br><span class="line">nameAgeMap.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 至于 std::unordered_map，与 std::map 的接口都是一样的</span></span><br><span class="line"><span class="comment">// 两者只在内部实现有区别</span></span><br><span class="line"><span class="comment">// 通常情况下，std::map 内存使用更少，而 std::unordered_map 查找更快 </span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Java</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java标准库中提供了一些常用的哈希算法（如MD系和SHA系），并且统一了接口</span></span><br><span class="line"><span class="keyword">import</span> java.math.MessageDigest;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 此处示例使用了MD5算法，修改该处的字符串即可切换算法</span></span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        <span class="comment">// 下述代码向哈希算法连续输入值，实际上等于输入&quot;HelloWorld&quot;</span></span><br><span class="line">        md.update(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        md.update(<span class="string">&quot;World&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取UTF-8编码的&quot;HelloWorld&quot;的哈希值</span></span><br><span class="line">        <span class="type">byte</span>[] result = md.digest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String类实际上提供了一个快速的哈希函数</span></span><br><span class="line"><span class="comment">// 我没有查到String.hashCode()所使用的具体哈希算法，还望各位相告</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringFastHash</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;The hash code is:&quot;</span> + str.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java标准库中提供了两个哈希表：Hashtable和HashMap</span></span><br><span class="line"><span class="comment">// 两者都实现了Map接口</span></span><br><span class="line"><span class="comment">// 值得一提的区别是HashMap不能线程同步且键值可为null，Hashtable反之</span></span><br><span class="line"><span class="comment">// 其余的虽然也有区别，但是相差不大，只需要记得HashMap单线程里比另一者快就是</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String,Integer&gt; ages = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;();</span><br><span class="line">        <span class="comment">// 添加键值对示例</span></span><br><span class="line">        ages.put(<span class="string">&quot;Hatsune Miku&quot;</span>,<span class="number">15</span>);</span><br><span class="line">        ages.put(<span class="string">&quot;ZUN&quot;</span>,<span class="number">45</span>);</span><br><span class="line">        <span class="comment">// 访问元素示例</span></span><br><span class="line">        System.out.println(ages.get(<span class="string">&quot;ZUN&quot;</span>));</span><br><span class="line">        <span class="comment">// 删除元素示例</span></span><br><span class="line">        ages.remove(<span class="string">&quot;ZUN&quot;</span>);</span><br><span class="line">        <span class="comment">// 清空元素示例</span></span><br><span class="line">        ages.clear();</span><br><span class="line">        <span class="comment">// 计算元素数量示例</span></span><br><span class="line">        System.out.println(ages.size());</span><br><span class="line">        <span class="comment">// 迭代键</span></span><br><span class="line">        <span class="keyword">for</span>(String name: ages.values()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> age: ages.keySet()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其余类方法略，请自行查表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 至于Hashtable，大体接口也与HashMap类似，略</span></span><br></pre></td></tr></table></figure>
<h1 id="使用C语言搓一个简单的哈希算法"><a href="#使用C语言搓一个简单的哈希算法" class="headerlink" title="使用C语言搓一个简单的哈希算法"></a>使用C语言搓一个简单的哈希算法</h1><p>这里用的是FNV-1a算法（32bit），真的很简单。</p>
<p>FNV-1a属于非加密哈希函数，支持32bit&#x2F;64bit&#x2F;128bit&#x2F;256bit&#x2F;512bit&#x2F;1024bit的输出，根据输出长度的不同，其使用的常量不同，而算法不变。</p>
<p>wiki上有这样一段描述FNV-1a的伪代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">algorithm fnv-1a is</span><br><span class="line">    hash := FNV_offset_basis</span><br><span class="line"></span><br><span class="line">    for each byte_of_data to be hashed do</span><br><span class="line">        hash := hash XOR byte_of_data</span><br><span class="line">        hash := hash × FNV_prime</span><br><span class="line"></span><br><span class="line">    return hash</span><br></pre></td></tr></table></figure>

<p>可以看出这个算法非常简单，将初始哈希值循环进行乘法与异或运算即可得到哈希值。</p>
<p>查表可知，输出32bit的FNV-1a算法使用的两个常量FNV_offset_basi与FNV_prime分别有如下取值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> HASH_OFFSET_BASIS_32 = <span class="number">0x811C9DC5</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> FNV_PRIME_32         = <span class="number">16777619</span>;</span><br></pre></td></tr></table></figure>

<p>然后根据伪代码编写循环即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> hash = HASH_OFFSET_BASIS_32;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(data); i++)</span><br><span class="line">&#123;</span><br><span class="line">    hash ^= data[i];</span><br><span class="line">    hash *= FNV_PRIME_32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">fnv1a_32</span><span class="params">(<span class="type">char</span>* data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// FNV-1a算法根据输出位数不同，各常量的值不同，此处为输出32bit的版本</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> HASH_OFFSET_BASIS_32 = <span class="number">0x811C9DC5</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> FNV_PRIME_32         = <span class="number">16777619</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> hash = HASH_OFFSET_BASIS_32;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(data); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        hash ^= data[i];</span><br><span class="line">        hash *= FNV_PRIME_32;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用C语言搓一个简单的哈希表"><a href="#使用C语言搓一个简单的哈希表" class="headerlink" title="使用C语言搓一个简单的哈希表"></a>使用C语言搓一个简单的哈希表</h1><p>哈希表（Hashmap）是一种容器，实际上更像是一种加强版的数组，只不过数组是用数字下标映射地址，而哈希表通过哈希函数。</p>
<p>你可能听不懂，我们先来回顾一下传统的C-Style数组，是通过头指针+偏移量实现的，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nums[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// 下述两段语句等价</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,nums[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*nums);</span><br><span class="line"><span class="comment">// 下述两段语句等价</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,nums[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">// 头指针nums + 偏移量2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(nums + <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>这种方法简单粗暴但十分有效，无论数组中有多少个元素，索引总是一步就完成的（只需要按特定量偏移头指针），时间复杂度恒为O(1)。</p>
<p>假如我们需要建立一个数据结构，用于储存书名和对应的价格，按照上述思路可以这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">float</span> price;</span><br><span class="line">&#125; Book;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BOOK_COUNT 10;</span></span><br><span class="line">Book books[MAX_BOOK_COUNT]</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化books</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initializeBooks</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Book* book;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAX_BOOK_COUNT;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        book = books + i;</span><br><span class="line">        book-&gt;price = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来不错，我们优雅地将书名和价格封装到了一个数据结构里，然后创建了他们的数组，一切看起来都很美好，只不过索引的方式有些许…弱智。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录一本书的价格</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addBook</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">float</span> price)</span></span><br><span class="line">&#123;</span><br><span class="line">    books[count].price = price;</span><br><span class="line">    <span class="built_in">strcpy</span>(books[count].name,name);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一本书的价格</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">getPrice</span><span class="params">(<span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line">    Book* book;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAX_BOOK_COUNT;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        book = books + i;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(name,book-&gt;name) == <span class="number">0</span>) <span class="keyword">return</span> book-&gt;price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个获取价格的操作的时间复杂度是O(n)，当BOOK_COUNT变大，耗时会线性增加。</p>
<p>想象一下你想要找到一本书的价格，然后翻遍了整个图书馆。</p>
<p>但你有没有想过，如果你有一个机器人，当你告诉它你要找的书的名字，它就会立即告诉你书的位置，于是你就能快速找到那本书的价格了。</p>
<p>像这样的带有”机器人“的图书馆，我们也许可以叫它，哈希图书馆。</p>
<p>这就是哈希结构，所谓的”机器人“，就是哈希函数。</p>
<p>来试试看吧。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BOOK_COUNT 10;</span></span><br><span class="line"><span class="comment">// 哈希表依然使用数组储存数据，和传统数组结构相比，只改变了索引方式</span></span><br><span class="line"><span class="type">float</span> bookPriceHashmap[MAX_BOOK_COUNT];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initializeBooksHashmap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAX_BOOK_COUNT;i++) bookPriceHashmap[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希函数，此处使用之前的FNV-1a算法+取余法以限定值域</span></span><br><span class="line"><span class="comment">// 虽然简单，但这样做会导致哈希碰撞（哈希冲突）的可能性增加</span></span><br><span class="line"><span class="comment">// 想要保证足够低的碰撞几率，就得提高数组容量，使用更多内存</span></span><br><span class="line"><span class="comment">// 可是哈希表的本质就是用内存换时间，不是吗？</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> fnv1a_32(str) % MAX_BOOK_COUNT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录一本书的价格</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addBook</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">float</span> price)</span></span><br><span class="line">&#123;</span><br><span class="line">    bookPriceHashmap[hash(name)] = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一本书的价格</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">getPrice</span><span class="params">(<span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> bookPriceHashmap[hash(name)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，索引过程中仅仅在计算哈希时进入了循环，两个操作的时间复杂度都是O(1)，基本只需要考虑哈希算法的耗时，而获得哈希值后真正的索引耗时基本可以忽略不计。</p>
<p>上述哈希表的完整测试代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">fnv1a_32</span><span class="params">(<span class="type">char</span>* data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// FNV-1a算法根据输出位数不同，各常量的值不同，此处为输出32bit的版本</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> HASH_OFFSET_BASIS_32 = <span class="number">0x811C9DC5</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> FNV_PRIME_32         = <span class="number">16777619</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> hash = HASH_OFFSET_BASIS_32;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(data); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        hash ^= data[i];</span><br><span class="line">        hash *= FNV_PRIME_32;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BOOK_COUNT 10</span></span><br><span class="line"><span class="type">float</span> bookPriceHashmap[MAX_BOOK_COUNT];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initializeBooksHashmap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAX_BOOK_COUNT;i++) bookPriceHashmap[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> fnv1a_32(str) % MAX_BOOK_COUNT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addBook</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">float</span> price)</span></span><br><span class="line">&#123;</span><br><span class="line">    bookPriceHashmap[hash(name)] = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一本书的价格</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">getPrice</span><span class="params">(<span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> bookPriceHashmap[hash(name)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    addBook(<span class="string">&quot;三体1&quot;</span>, <span class="number">1145.14f</span>);</span><br><span class="line">    addBook(<span class="string">&quot;三体2&quot;</span>, <span class="number">19198.10f</span>);</span><br><span class="line">    addBook(<span class="string">&quot;The Selfish Gene&quot;</span>, <span class="number">99.61f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The price of 三体1 is %.2f\n&quot;</span>,getPrice(<span class="string">&quot;三体1&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The price of 三体2 is %.2f\n&quot;</span>,getPrice(<span class="string">&quot;三体2&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The price of The Selfish Gene is %.2f\n&quot;</span>,getPrice(<span class="string">&quot;The Selfish Gene&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以试试减小 MAX_BOOK_COUNT，然后添加更多的书本，感受一下哈希碰撞。</p>
<p>另外，哈希表其实是在用空间换取时间，在保证较小的碰撞概率的前提下，储存同样多元素的哈希表所占用的内存空间要明显大于数组。你可以编译并Debug上面的代码，查看 bookPriceHashmap 的内存，被修改过的非0数字散乱地分布在哈希表的内存片段中，这也是为什么哈希被称为”散列“。</p>
<p>不过话又说回来，除非是在搞嵌入式，有谁会在意那点内存呢？</p>
<h1 id="哈希表与数组的性能对比"><a href="#哈希表与数组的性能对比" class="headerlink" title="哈希表与数组的性能对比"></a>哈希表与数组的性能对比</h1><p>将上述代码的 MAX_BOOK_COUNT 修改为 30000000，向容器中填充 MAX_BOOK_COUNT&#x2F;4 个元素，然后分别测试哈希表与数组索引一个插入于 MAX_BOOK_COUNT&#x2F;8 位置的值，实验代码和结果如下。</p>
<ol>
<li>哈希表</li>
</ol>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">fnv1a_32</span><span class="params">(<span class="type">char</span>* data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// FNV-1a算法根据输出位数不同，各常量的值不同，此处为输出32bit的版本</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> HASH_OFFSET_BASIS_32 = <span class="number">0x811C9DC5</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> FNV_PRIME_32         = <span class="number">16777619</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> hash = HASH_OFFSET_BASIS_32;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(data); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        hash ^= data[i];</span><br><span class="line">        hash *= FNV_PRIME_32;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BOOK_COUNT 30000000</span></span><br><span class="line"><span class="type">float</span> bookPriceHashmap[MAX_BOOK_COUNT];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initializeBooksHashmap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAX_BOOK_COUNT;i++) bookPriceHashmap[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> fnv1a_32(str) % MAX_BOOK_COUNT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addBook</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">float</span> price)</span></span><br><span class="line">&#123;</span><br><span class="line">    bookPriceHashmap[hash(name)] = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一本书的价格</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">getPrice</span><span class="params">(<span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> bookPriceHashmap[hash(name)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">5</span>] = <span class="string">&quot;3体1&quot;</span>;</span><br><span class="line">    <span class="type">float</span> price = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAX_BOOK_COUNT / <span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == MAX_BOOK_COUNT / <span class="number">8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            addBook(<span class="string">&quot;C为什么是神&quot;</span>, <span class="number">114.51f</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++) name[j] += <span class="number">1</span>;</span><br><span class="line">        addBook(name, ++price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">clock_t</span> begin,end;</span><br><span class="line">    begin=clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;《C为什么是神》的价格是: %.2f\n&quot;</span>,getPrice(<span class="string">&quot;C为什么是神&quot;</span>));</span><br><span class="line">    end=clock();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>,(<span class="type">double</span>)(end-begin)/CLOCKS_PER_SEC);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>数组</li>
</ol>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">float</span> price;</span><br><span class="line">&#125; Book;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BOOK_COUNT 30000000</span></span><br><span class="line">Book books[MAX_BOOK_COUNT];</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化books</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initializeBooks</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Book* book;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAX_BOOK_COUNT;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        book = books + i;</span><br><span class="line">        book-&gt;price = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录一本书的价格</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addBook</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">float</span> price)</span></span><br><span class="line">&#123;</span><br><span class="line">    books[count].price = price;</span><br><span class="line">    <span class="built_in">strcpy</span>(books[count].name,name);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一本书的价格</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">getPrice</span><span class="params">(<span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line">    Book* book;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAX_BOOK_COUNT;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        book = books + i;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(name,book-&gt;name) == <span class="number">0</span>) <span class="keyword">return</span> book-&gt;price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">5</span>] = <span class="string">&quot;3体1&quot;</span>;</span><br><span class="line">    <span class="type">float</span> price = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAX_BOOK_COUNT / <span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == MAX_BOOK_COUNT / <span class="number">8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            addBook(<span class="string">&quot;C为什么是神&quot;</span>, <span class="number">114.51f</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++) name[j] += <span class="number">1</span>;</span><br><span class="line">        addBook(name, ++price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">clock_t</span> begin,end;</span><br><span class="line">    begin=clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;《C为什么是神》的价格是: %.2f\n&quot;</span>,getPrice(<span class="string">&quot;C为什么是神&quot;</span>));</span><br><span class="line">    end=clock();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>,(<span class="type">double</span>)(end-begin)/CLOCKS_PER_SEC);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>结果</li>
</ol>
<p>  使用Linux中的time命令计时，有如下结果</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>第一次</th>
<th>第二次</th>
<th>第三次</th>
<th>第四次</th>
<th>平均</th>
</tr>
</thead>
<tbody><tr>
<td>哈希表</td>
<td>0.000075</td>
<td>0.000065</td>
<td>0.000075</td>
<td>0.000074</td>
<td>0.00007225</td>
</tr>
<tr>
<td>数组</td>
<td>0.010207</td>
<td>0.010820</td>
<td>0.011146</td>
<td>0.011140</td>
<td>0.01082825</td>
</tr>
</tbody></table>
<p>  由此我们得到一个恐怖的结果，在该项测试中，哈希表的索引速度大约是数组的150倍，且随着 MAX_BOOK_COUNT 的增加，差距还会继续增大。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">散列函数 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304227729113121">哈希算法 - 廖雪峰的官方网站</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43935927/article/details/109126787">【必备算法】哈希算法：七种应用及场景示例_A minor的博客-CSDN博客_哈希算法简单举例</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/97763484">哈希算法及其应用场景 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-1a_hash">Fowler–Noll–Vo hash function - Wikipedia</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/huangkangying/article/details/8748537">常用Hash算法(C语言实现)_huangkangying的博客-CSDN博客_hash函数c语言实现</a></p>
<p><a target="_blank" rel="noopener" href="https://security.stackexchange.com/a/11841">https://security.stackexchange.com/a/11841</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/09/07/%E5%A6%82%E4%BD%95%E7%9C%8B%E6%87%82%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84big-O%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/07/%E5%A6%82%E4%BD%95%E7%9C%8B%E6%87%82%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84big-O%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">如何看懂时间复杂度的big-O表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-07 23:15:27" itemprop="dateCreated datePublished" datetime="2022-09-07T23:15:27+08:00">2022-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-04 16:20:54" itemprop="dateModified" datetime="2022-10-04T16:20:54+08:00">2022-10-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0x0"><a href="#0x0" class="headerlink" title="0x0"></a>0x0</h1><p>从前我一直看不懂这些，其实大抵还是因为懒，最近终于有一些理由让我去查一些资料了，所以顺手写一点。我也不是什么大佬，理解上难免有偏差，如果有误，烦请各位指出，感谢。</p>
<p>不知道你在学习算法的过程中，有没有遇见过这个东西：</p>
<ul>
<li><p>$O(1)$</p>
</li>
<li><p>$O(n)$</p>
</li>
<li><p>$O(x^2)$</p>
</li>
<li><p>$O(n log n)$</p>
</li>
<li><p>$O(n)$</p>
</li>
<li><p>$O(log n)$</p>
</li>
<li><p>$O(n!)$</p>
</li>
<li><p>$O(2^n)$</p>
</li>
</ul>
<p>这是<strong>时间复杂度</strong>的<strong>大O表示法</strong>，其中的O是一个函数，定义为$T[n] &#x3D; O(f(n))$，它不仅可以表示时间的复杂度，还能表示空间的复杂度。</p>
<p>那么，什么是时间复杂度呢？</p>
<h1 id="0x1：时间复杂度"><a href="#0x1：时间复杂度" class="headerlink" title="0x1：时间复杂度"></a>0x1：时间复杂度</h1><p>试想一下，如果我给你这样一排…P，请你挨个拾取它们。</p>
<img src="https://i.postimg.cc/FRxy8PZ1/1.png" width=75 height=25/>

<p>听起来就很容易，那这样呢？</p>
<img src="https://i.postimg.cc/T27mb5H8/2.png" width=1000 height=30/>

<p>很明显，如果设P点的个数为x，捡起一个P点需要的时间固定，那么对于捡起所有P点所耗费的时间总量t在大体上有如下图像：</p>
<img src="https://i.postimg.cc/v8NgTFcb/2022-09-06-20-35-41-image.png" width=300 height=200/>

<p>这实际上是一个 y &#x3D; x (x $\geqslant$ 0，下略) 图像</p>
<p>类似的，如果我要求你每捡起一个P点就释放P点总数个Bomb，那图像会变成这样：</p>
<img src="https://i.postimg.cc/MXJzBYCb/2022-09-06-20-48-17-image.png" width=300 height=200/>

<p>这实际上是一个 $y &#x3D; x^2$ 图像</p>
<p>拿第一个例子来说，像这样的，以捡起所有P点为例，这个操作所需要耗费的时间 <strong>t</strong> 随着P点数量 <strong>x</strong> 的增多，以一个恒定的速率 <strong>k</strong>（假设捡起两个P点的操作之间没有间隔，k为捡起一个P点的用时），那么就有 $t &#x3D; kx$，由此我们可以说：这个操作的时间复杂度可以表示为 $O(n)$</p>
<p>现在你再看看那些 $O(1)$，$O(n^2)$，是不是有点感觉了？</p>
<h1 id="0x2：big-O表达式"><a href="#0x2：big-O表达式" class="headerlink" title="0x2：big-O表达式"></a>0x2：big-O表达式</h1><p>O(…)，即大O表达式（big-O），常用于表达某种操作（算法）的<strong>耗时上界</strong>，它从大体上<strong>粗略地</strong>描述了一个算法所需要的时间，即它的<strong>时间复杂度</strong>。正如前例，big-O表达式使用一个简单的式子来从大体上形容一种耗时的概念，通过big-O表达式，我们能一眼看出操作大体上的时间复杂度，即耗时与数据量的大体关系。</p>
<p>需要注意的是，就以 $O(n^2)$ 而言，经管实际上的耗时可能并不是 $t &#x3D; n^2$（或者是我们举的第一个例子，捡起两个P点之间是肯定有时间间隔的），只是因为某种关系，它的整体耗时的变化曲线和 $y &#x3D; x^2$ 类似（至少看起来有那么一点类似），所以我们可以用 $O(n^2)$ 来形容它的时间复杂度。</p>
<p>数学需要讲究逻辑的严密，准确，但我们学的毕竟不是真正的数学。</p>
<h1 id="0x3：三个简单的大O表达式以及对应代码示例"><a href="#0x3：三个简单的大O表达式以及对应代码示例" class="headerlink" title="0x3：三个简单的大O表达式以及对应代码示例"></a>0x3：三个简单的大O表达式以及对应代码示例</h1><ol>
<li>$O(1)$</li>
</ol>
<p>  表示时间复杂度是一个常数，总耗时恒定。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMax</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>$O(n)$</li>
</ol>
<p>  表示时间复杂度解析图像类似于 $y &#x3D; x$ 的图像，总耗时随着处理量的增加而线性增长。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMax</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt; list)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> buffer = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; item : list) <span class="keyword">if</span>(item &gt; buffer) buffer = item;</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>$O(n^2)$</li>
</ol>
<p>  表示时间复杂度解析图像类似于 $y &#x3D; x^2$ 图像，随着处理量的增加，总耗时成次方增长。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foreachAudioListDo</span><span class="params">(AudioListManager&amp; manager)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; list : manager)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; sound : list) sound.<span class="built_in">play</span>();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x4：big-O的加法"><a href="#0x4：big-O的加法" class="headerlink" title="0x4：big-O的加法"></a>0x4：big-O的加法</h1><p>之前提过一点，时间复杂度表示的是<strong>上界</strong>（极限），当两个算法共用（此处不考虑嵌套）时，整体的时间复杂度未必是直接相加，全看二者之中占大头者，例如：</p>
<p>$O(n) + O(2^n) &#x3D; O(2^n)$</p>
<h1 id="0x5：关于-O-log-n"><a href="#0x5：关于-O-log-n" class="headerlink" title="0x5：关于$O(log n)$"></a>0x5：关于$O(log n)$</h1><p>需要注意的是，这里的 log 是省略了下标 2 的，实际上应该写做 $O(log_2n)$ ，但是这样做毕竟太麻烦，在一些环境下也打不出这个下标，就简化到只留下 log 了。</p>
<p>带 log 的几个大O表达式都比较迷惑人，实际上，同其他任何的大O表达式一样，只要画出他们的图像即可。</p>
<img src="https://i.postimg.cc/7Y15VCKY/2022-09-07-22-50-42-image.png" width=300 height=200/>

<p>这是 $y &#x3D; log_2x$ 的图像</p>
<p>$O(log n)$ 的一个典型例子是二分查找，在二分查找中，每查找一次，下一次查找所需要处理的数据量就是上一次的一半。</p>
<p>别看着 $log_2n$ 好像很复杂，实际上，$O(log_2n)$ 介于 $O(n)$ 和 $O(1)$ 之间，是全体程序员努力的方向。</p>
<h1 id="0x6：参考资料"><a href="#0x6：参考资料" class="headerlink" title="0x6：参考资料"></a>0x6：参考资料</h1><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95/1851162">大O表示法_百度百科 (baidu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/248284657">O(log(N))是什么意思 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1DY4y1H7DGhttps://www.bilibili.com/video/BV1DY4y1H7DG">常见的大O表示法有哪些？时间复杂度是什么？(bilibili.com)</a></p>
<p>本文使用的函数图像生成并截取自<a target="_blank" rel="noopener" href="https://www.desmos.com/calculator?lang=zh-CN">Desmos | 图形计算器</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/31/C-%E4%B8%AD%E7%9A%84%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/31/C-%E4%B8%AD%E7%9A%84%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/" class="post-title-link" itemprop="url">C++中的重载运算符</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-31 17:35:11 / 修改时间：18:28:43" itemprop="dateCreated datePublished" datetime="2022-08-31T17:35:11+08:00">2022-08-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这个部分我老是学了又忘，忘了又学…再写一遍吧。</p>
<h1 id="什么是重载运算符"><a href="#什么是重载运算符" class="headerlink" title="什么是重载运算符"></a>什么是重载运算符</h1><p>学习编程之初我们就接触过一些运算符，比如这样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* a;</span><br><span class="line">*a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>( *a + b == d)</span><br><span class="line">&#123;</span><br><span class="line">    func(myArray[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里的 * ，+ ，&#x3D;&#x3D; ，[ ]，都是运算符，你可曾想过，在C++中，我们可以使用一个函数来重载他们？</p>
<p>你可能听不懂我在说什么，也搞不懂重载他们有什么用，我给你看一段代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="comment">// 我最近写的一个加载.png文件的类，就叫Image</span></span><br><span class="line"><span class="comment">// 我截取了工程中的部分代码，这是没有重载运算符时，它的使用操作</span></span><br><span class="line"></span><br><span class="line"><span class="function">Image <span class="title">img</span><span class="params">(<span class="string">&quot;a.png&quot;</span>)</span></span>;</span><br><span class="line">Pixel pixel = img.<span class="built_in">getPixel</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这是重载[]运算符后的效果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="function">Image <span class="title">img</span><span class="params">(<span class="string">&quot;a.png&quot;</span>)</span></span>;</span><br><span class="line">Pixel pixel = img[<span class="number">1</span>][<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>再举个例子，假如你自己定义了一个超大数类，叫SuperBigNum，在不重载运算符时，想要两者相加，你可能需要这样写。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SuperBigNum <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">SuperBigNum <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">a.<span class="built_in">add</span>(b);</span><br></pre></td></tr></table></figure>

<p>但重载运算符后，你可以这样写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SuperBigNum <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">SuperBigNum <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">a += b;</span><br></pre></td></tr></table></figure>

<p>你可能还看不出来这有啥用，让代码里难看的符号多点，用的时候少打几个字？</p>
<p>事实上，重载运算符统一了代码编写时相同逻辑的代码操作，使得模板具有更大的发挥空间，我随意举一个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有俩类，Box和Cube，现在有一个进行加法操作的函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T t1,T t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//return t1 + t2;</span></span><br><span class="line">    <span class="comment">// or something else</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在不重载运算符的情况下，你能让这一个模板同时兼容Box和Cube类吗？</span></span><br></pre></td></tr></table></figure>

<p>ISO C++ 98的一大招牌就是模板，可见重载运算符的意义。</p>
<h1 id="那些运算符可以重载"><a href="#那些运算符可以重载" class="headerlink" title="那些运算符可以重载"></a>那些运算符可以重载</h1><p>不可重载的运算符如下</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>成员访问运算符</td>
</tr>
<tr>
<td>.* 和 -&gt;*</td>
<td>成员指针访问运算符</td>
</tr>
<tr>
<td>::</td>
<td>域运算符</td>
</tr>
<tr>
<td>sizeof</td>
<td>长度运算符</td>
</tr>
<tr>
<td>?:</td>
<td>条件运算符（三元表达式）</td>
</tr>
<tr>
<td>#</td>
<td>预处理符号</td>
</tr>
</tbody></table>
<p>除上述内容外，所有的运算符都能被重载，甚至包括new与delete。</p>
<h1 id="如何重载运算符"><a href="#如何重载运算符" class="headerlink" title="如何重载运算符"></a>如何重载运算符</h1><p>其语法大致如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以class Box为例，重载其+运算符</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//...</span></span><br><span class="line">    Box <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp;);<span class="comment">//参数中的Box是被加的Box的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然重载运算符也可以在类外进行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运算符左右的两者都列入参数</span></span><br><span class="line">Box <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp; b1,<span class="type">const</span> Box&amp; b2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对其他运算符的重载也是类似的操作，只需要注意参数即可。</p>
<p>顺便一提，谁说一定要有Box + Box &#x3D; Box呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp; b1,<span class="type">const</span> Box&amp; b2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (b1.<span class="built_in">add</span>(b2)).<span class="built_in">getLength</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又为何下标里的参数一定是个int呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Image</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//...</span></span><br><span class="line">    Pixel <span class="keyword">operator</span>[](std::array&lt;<span class="type">int</span>,<span class="number">2</span>&gt; pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Image.<span class="built_in">getPixel</span>(pos[<span class="number">0</span>],pos[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一切皆有可能。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-overloading.html">C++ 重载运算符和重载函数 | 菜鸟教程 (runoob.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/29/C%E8%AF%AD%E8%A8%80%E4%B8%ADpthread%E6%88%96Windows-API%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/29/C%E8%AF%AD%E8%A8%80%E4%B8%ADpthread%E6%88%96Windows-API%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">C语言中pthread或Windows API在多线程编程中的基本应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-29 02:29:37 / 修改时间：02:45:46" itemprop="dateCreated datePublished" datetime="2022-08-29T02:29:37+08:00">2022-08-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>警告</p>
<ol>
<li><p>由于我懒得写完，而且懂的也不是很多，本文不会深入各个多线程库，不会涉及具体的高并发，原子操作等复杂内容，本文仅描述了C语言中多线程技术的基本使用方法<del>，适合新人。</del></p>
</li>
<li><p>由于threads.h与pthread.h定位冲突且资料较少，我没有对thread.h深究，仅仅列出部分宏&#x2F;函数表</p>
</li>
<li><p>实际上posix环境下的多线程库（还有C++的threads）都大差不差，思路都是互通的，只有Windows是个异类，所以本文重心在于pthread和Windows API的CreateThread。</p>
</li>
<li><p>阅读本文需要一定的基础。</p>
</li>
</ol>
<h1 id="多线程概述"><a href="#多线程概述" class="headerlink" title="多线程概述"></a>多线程概述</h1><p>现代操作系统通常以进程（process）作为CPU资源调度的最小单位，其实际上是线程的容器，而线程则是程序指令以及其资源的容器，从这样的角度，我们可以这样说：线程即是“程序”。</p>
<ul>
<li>我们为什么要使用多线程？</li>
</ul>
<p>原因是多种多样的，扯远一点，由于摩尔定律的失效（CPU单核性能在短期内无法取得决定性的进步），红蓝两家都在往CPU上堆核心，广大程序员无法享用单核红利。而着眼于手边，你可能会为了实现一个好看的读条界面而转向超线程，或者可能是为了在读取文件的同时输出日志，或者仅仅是想给自己的CPU来一次压力测试…</p>
<ul>
<li>如何获得多核红利？</li>
</ul>
<p>高效利用你的CPU核心的方式多种多样，其中最朴实无华（但实际上也能复杂得让人头痛）的便是多线程技术。ISO C 11提供了一个标准库头文件threads.h以提供多线程功能（但截至目前，Visual Studio未提供相应实现），在posix环境中也可以使用pthread.h，对于Windows环境，也能使用Windows API来管理线程。</p>
<h1 id="掌握多线程需要学习什么？"><a href="#掌握多线程需要学习什么？" class="headerlink" title="掌握多线程需要学习什么？"></a>掌握多线程需要学习什么？</h1><ol>
<li><p>学会创建一个线程</p>
</li>
<li><p>学会管理线程</p>
</li>
<li><p>学会使用互斥锁缓解线程安全问题</p>
</li>
<li><p>…</p>
</li>
</ol>
<p>实际上，多线程是一个大坑，非常坑，远远不止上述内容。</p>
<p>如果要深究，还得涉及到操作系统层面的调度，甚至是硬件层面的乱序发射。</p>
<h1 id="使用pthread-h实现多线程"><a href="#使用pthread-h实现多线程" class="headerlink" title="使用pthread.h实现多线程"></a>使用pthread.h实现多线程</h1><p>使用pthread需要链接pthread.so（或windows上的libwinpthread），mingw-w64 gcc若使用posix线程模型则默认链接该库，而linux上的gcc则需要手动配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动编译示例</span></span><br><span class="line">gcc main.c -o app -lpthread</span><br></pre></td></tr></table></figure>

<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake示例</span></span><br><span class="line"><span class="keyword">add_executable</span>(learning_pthread)</span><br><span class="line"><span class="keyword">target_sources</span>(learning_pthread PUBLIC main.c)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(learning_pthread PUBLIC pthread)</span><br></pre></td></tr></table></figure>

<p>pthread.h的内容几乎都以pthread_开头，请看如下示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">say</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) <span class="built_in">puts</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1;</span><br><span class="line">    <span class="type">pthread_t</span> t2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原型为 pthread_create(pthread_t *restrict newthread, const pthread_attr_t *restrict attr, void *(*start_routine)(void *), void *restrict arg)</span></span><br><span class="line">    <span class="comment">// 此处第四个参数进行了隐式转换</span></span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, say, <span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, say, <span class="string">&quot;pthread is awesome!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非阻塞</span></span><br><span class="line">    pthread_detach(t1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞当前线程，可以指定返回值到何处，但此处不需要，故设为NULL</span></span><br><span class="line">    pthread_join(t2,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) <span class="built_in">puts</span>(<span class="string">&quot;if you see this , the main thread is still alive!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外，你可以使用如下函数强行终止一个线程</span></span><br><span class="line"><span class="comment">//void  pthread_exit（void  *retval）;</span></span><br><span class="line"><span class="comment">// 你还可以使用下述函数获得当前线程标识</span></span><br><span class="line"><span class="comment">//pthread_t pthread_self(void);</span></span><br></pre></td></tr></table></figure>

<p>编译并运行上述代码，你应该能发现“hello world”和“pthread is awesome”交替输出，但是一者输出一段时间后换为另一者进行输出，这是因为每个线程都分配到了一定的CPU时间片，当自己的时间片用尽时才会让出CPU，让其他线程执行，线程其实并没有同步执行，只是高速切换。</p>
<p>最后的“if you see this , the main thread is still alive!”是不会被输出的，因为主线程执行到“pthread_join(t2,NULL);”时就被堵塞了。</p>
<p>pthread中也提供了互斥锁以<strong>缓解</strong>线程安全问题，和其他的多线程库一样，其操作总结下来无非就是</p>
<ol>
<li><p>创建mutex</p>
</li>
<li><p>对关键IO操作上锁</p>
</li>
<li><p>完成关键IO操作后解锁</p>
</li>
</ol>
<p>放到代码中就像是这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mut;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">counter</span><span class="params">(<span class="type">void</span>* args)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= <span class="number">10000</span> / <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 对非本线程资源的读写，可能存在冲突，故上锁</span></span><br><span class="line">		pthread_mutex_lock(&amp;mut);</span><br><span class="line">		g_number++;</span><br><span class="line">		pthread_mutex_unlock(&amp;mut);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种直接上锁的方式尽管简单易用，但却实际上使程序的IO部分退化回了单线程，造成了一定的性能损失。而想要解决这个问题，我们就得来谈谈“原子操作”了。</p>
<p>原子操作是一种复杂且经过数次迭代的机制，简单来说，它是一个不可中断的，一系列的操作，它不会被线程调度机制打断，也不会有任何的上下文切换。使用原子操作，能完美解决传统mutex锁策略所带来的性能损失，同时保证线程安全。</p>
<p>你可能好奇如此神奇的机制到底是如何实现的，其实，时至今日，原子操作早已不单是标准库中的一套概念，而是整合进了CPU的一套指令集。原子操作的底层是由CPU硬件实现的。</p>
<p>在ISO C 11中标准库提供了stdatomic.h，我们可以用它来实现原子操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码截取自zh.cppreference.com</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;threads.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdatomic.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">atomic_int</span> acnt;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>* thr_data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">1000</span>; ++n) &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">        ++acnt;</span><br><span class="line">        <span class="comment">// 对于此例，宽松内存顺序是足够的，例如</span></span><br><span class="line">        <span class="comment">// atomic_fetch_add_explicit(&amp;acnt, 1, memory_order_relaxed);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">thrd_t</span> thr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; ++n)</span><br><span class="line">        thrd_create(&amp;thr[n], f, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; ++n)</span><br><span class="line">        thrd_join(thr[n], <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The atomic counter is %u\n&quot;</span>, acnt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The non-atomic counter is %u\n&quot;</span>, cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用Windows-API实现多线程"><a href="#使用Windows-API实现多线程" class="headerlink" title="使用Windows API实现多线程"></a>使用Windows API实现多线程</h1><p>其实在我看来，使用Windows API是迫不得已的下下策，但无可否认的是，如此的”迫不得已“，实在是太普遍了。</p>
<p>Windows API有个特色，就是参数列表又臭又长，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line">HANDLE <span class="title function_">CreateThread</span><span class="params">(</span></span><br><span class="line"><span class="params">                    LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span><br><span class="line"><span class="params">                    DWORD dwStackSize,</span></span><br><span class="line"><span class="params">                    LPTHREAD_START_ROUTINE lpStartAddress,</span></span><br><span class="line"><span class="params">                    LPVOID lpParameter,</span></span><br><span class="line"><span class="params">                    DWORD dwCreationFlags,</span></span><br><span class="line"><span class="params">                    LPDWORD lpThreadID</span></span><br><span class="line"><span class="params">                   )</span>;</span><br><span class="line"><span class="comment">// 其实这还不是最长的（小声</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>lpThreadAttrivutes</td>
<td>用于定义新线程的安全属性，一般为NULL</td>
</tr>
<tr>
<td>dwStackSize</td>
<td>线程堆栈的大小，单位字节，默认为0</td>
</tr>
<tr>
<td>lpStartAddress</td>
<td>线程函数地址，即此线程需要执行的函数</td>
</tr>
<tr>
<td>lpParameter</td>
<td>传给线程函数的参数</td>
</tr>
<tr>
<td>dwCreationFlags</td>
<td>创建线程的运行状态，CREATE_SUSPEND表示挂起，0表示立即执行</td>
</tr>
<tr>
<td>lpThreadID</td>
<td>回新创建的线程的ID</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待线程结束，其实也可以是等待其他东西</span></span><br><span class="line">DWORD <span class="title function_">WaitForSingleObject</span><span class="params">(</span></span><br><span class="line"><span class="params">                          HANDLE hHandle,</span></span><br><span class="line"><span class="params">                          DWORD dwMilliseconds</span></span><br><span class="line"><span class="params">                         )</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>hHandle</td>
<td>对象或时间的句柄</td>
</tr>
<tr>
<td>dwMilliseconds</td>
<td>最长等待时间，单位毫秒，若超过此最长时间则强制返回，亦可设为INFINITE，然后等待戈多（不</td>
</tr>
</tbody></table>
<p>Windows API也提供了与mutex锁类似的机制来缓解线程安全问题，叫”临界区“</p>
<p>其使用步骤大体为：</p>
<ol>
<li><p>创建临界区： CRITICAL_SECTION cs</p>
</li>
<li><p>初始化临界区：InitializeCriticalSection(&amp;cs)</p>
</li>
<li><p>在关键IO前进入临界区：EnterCriticalSection(&amp;cs);</p>
</li>
<li><p>关键IO结束后退出临界区：LeaveCriticalSection(&amp;cs);</p>
</li>
</ol>
<p>下面是一端演示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">CRITICAL_SECTION cs;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">func</span><span class="params">(LPVOID parament)</span></span><br><span class="line">&#123;</span><br><span class="line">    EnterCriticalSection(&amp;cs);</span><br><span class="line">    <span class="comment">// certain IO</span></span><br><span class="line">    i++;</span><br><span class="line">    LeaveCriticalSection(&amp;cs);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    HANDLE thread[<span class="number">2</span>];</span><br><span class="line">    DWORD ret1;</span><br><span class="line">    DWORD ret2;</span><br><span class="line"></span><br><span class="line">    InitializeCriticalSection(&amp;cs);</span><br><span class="line">    <span class="comment">// 两个线程都设置为立即执行，从效果上说和pthread_detach类似</span></span><br><span class="line">    thread[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, func, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    thread[<span class="number">1</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, func, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    WaitForMultipleObjects(<span class="number">2</span>, thread, TRUE, INFINITE);</span><br><span class="line">    CloseHandle(harrThread[<span class="number">0</span>]);</span><br><span class="line">    CloseHandle(harrThread[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用threads-h实现多线程"><a href="#使用threads-h实现多线程" class="headerlink" title="使用threads.h实现多线程"></a>使用threads.h实现多线程</h1><p>thread.h在ISO C 11标准后加入，请确保你的编译器支持且启用了ISO C 11标准。另外，Visual Studio尚未支持ISO C 11的threads.h，因为他们从来不关心C语言标准。</p>
<p>threads.h的函数均以thrd_开头，常用内容如下</p>
<table>
<thead>
<tr>
<th>标识符&#x2F;原型</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>thrd_t</td>
<td>宏</td>
<td>用于存放线程的相关数据，可以当成线程对象来使用</td>
</tr>
<tr>
<td>int thrd_create(thrd_t *thr, thrd_start_t func, void *arg);</td>
<td>函数</td>
<td>创建线程并指定其执行的函数</td>
</tr>
<tr>
<td>int thrd_detach(thrd_t thr);</td>
<td>函数</td>
<td>将子线程与主线程分离，使其与主线程并行</td>
</tr>
<tr>
<td>int thrd_equal(thrd_t thr0, thrd_t thr1);</td>
<td>函数</td>
<td>判断两个线程标识符是否标识同一线程</td>
</tr>
<tr>
<td>void thrd_exit(int res)</td>
<td>函数</td>
<td>强制结束某线程</td>
</tr>
<tr>
<td>int thrd_join(thrd_t thr, int *res)</td>
<td>函数</td>
<td>注意：我查到的资料中的描述和我实际测试的结果不同，我现有的资料都说此函数会阻塞当前线程，但实际测试结果并未阻塞，存疑。</td>
</tr>
<tr>
<td>void thrd_sleep(const xtime *xt)</td>
<td>函数</td>
<td>使当前线程休眠指定时间</td>
</tr>
<tr>
<td>void thrd_yield(void)</td>
<td>函数</td>
<td>挂起当前线程，让出CPU资源</td>
</tr>
</tbody></table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>(不分先后，随机排序)</p>
<p><a target="_blank" rel="noopener" href="https://www.ibadboy.net/archives/2323.html">C11新增多线程支持库-threads.h参考手册 – 坏蛋的博客 (ibadboy.net)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42055033/article/details/106560321">windows API（9）线程安全 临界区_飘零的落花的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012877472/article/details/49721653">使用CreateThread函数创建线程_Valineliu的博客-CSDN博客_createthread函数</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/97418361">C语言多线程编程(一) - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/c/language/atomic">原子类型 - cppreference.com</a></p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/1880992">原子操作_百度百科 (baidu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhuiyunzhugang/article/details/108147466">什么是原子操作_辽宁大学的博客-CSDN博客_原子操作</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/23/EasyX%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/23/EasyX%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">EasyX基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-23 15:05:18 / 修改时间：15:07:39" itemprop="dateCreated datePublished" datetime="2022-08-23T15:05:18+08:00">2022-08-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="EasyX"><a href="#EasyX" class="headerlink" title="EasyX"></a>EasyX</h1><blockquote>
<p>EasyX Graphics Library 是针对 Visual C++ 的免费绘图库，支持 VC6.0 ~ VC2022，简单易用，学习成本极低，应用领域广泛。目前已有许多大学将 EasyX 应用在教学当中。</p>
</blockquote>
<ol>
<li><p>EasyX其实是一个C++库，不是C库，这就像VC只有C++编译器，没有C编译器一样。</p>
</li>
<li><p>EasyX最初发布于2009年，其底层是gdi，设计上和Windows API高度耦合，但在使用上基本不用了解太多的Windows API。EasyX是一个图形库，或者说只是一个绘图库，因为它相较于OpenGL以及其他的如SDL2的库而言只有一个优势——简单易用。它能让新人快速上手，了解以及学习绘图算法。</p>
</li>
<li><p>如果你是一位新人，那么EasyX对你最大的吸引力大概在于：只用学习少量内容，就能暂时摆脱烦人的黑框框程序，窥得一眼五彩斑斓的GUI世界。</p>
</li>
<li><p>EasyX能干什么？EasyX可以绘图，这意味着它能实现一些图像处理功能，或者是一个游戏，一个数据分析软件，一个动画合成软件，等等等等，但需要明确的是，上述内容都不是单单一个EasyX就能完成的。</p>
</li>
</ol>
<h1 id="搭建EasyX的开发环境"><a href="#搭建EasyX的开发环境" class="headerlink" title="搭建EasyX的开发环境"></a>搭建EasyX的开发环境</h1><ol>
<li><p>由于与Windows API高度耦合，EasyX官方仅支持VC工具链，具体版本下至Visual C++ 6.0，上至Visual Studio 2022。（截至目前而言）</p>
</li>
<li><p>官方提供了一个<a target="_blank" rel="noopener" href="https://easyx.cn/download/EasyX_20220610.exe">安装程序</a>来完成各个版本VC&#x2F;VS上的一键式部署与卸载。（同时也提供了一个离线文档）</p>
</li>
</ol>
<h1 id="使用EasyX编写GUI程序的简单示例"><a href="#使用EasyX编写GUI程序的简单示例" class="headerlink" title="使用EasyX编写GUI程序的简单示例"></a>使用EasyX编写GUI程序的简单示例</h1><ol>
<li>引入EasyX库的头文件，旧版本的EasyX使用graphics.h（这也是你在网上能找到的大多数教程所用的头文件），但现在应该使用easyx.h。目前的graphics.h仅保留了若干已被easyx.h废弃的旧版功能。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;easyx.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>初始化绘图窗口，创建一个指定大小（此处示例为640x480像素）的窗口。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">initgraph</span>(<span class="number">640</span>, <span class="number">480</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>绘图，此处示例为绘制一个圆心为（200,200），半径为100的圆。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">circle</span>(<span class="number">200</span>, <span class="number">200</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>关闭绘图窗口</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">closegraph</span>();</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>完整代码</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">initgraph</span>(<span class="number">640</span>, <span class="number">480</span>);</span><br><span class="line">    <span class="built_in">circle</span>(<span class="number">200</span>, <span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">    _getch();</span><br><span class="line">    <span class="built_in">closegraph</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>运行效果</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/v6xQHI"><img src="https://s1.ax1x.com/2022/08/23/v6xQHI.png" alt="v6xQHI.png"></a></p>
<hr>
<h1 id="EasyX中的基本概念"><a href="#EasyX中的基本概念" class="headerlink" title="EasyX中的基本概念"></a>EasyX中的基本概念</h1><h2 id="EaysX中颜色的三种表示方式："><a href="#EaysX中颜色的三种表示方式：" class="headerlink" title="EaysX中颜色的三种表示方式："></a>EaysX中颜色的三种表示方式：</h2><ol>
<li><p>宏定义：EasyX内建了一些宏常量来表示颜色</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>值</th>
<th>颜色</th>
</tr>
</thead>
<tbody><tr>
<td>BLACK</td>
<td>0</td>
<td>黑</td>
</tr>
<tr>
<td>BLUE</td>
<td>0xAA0000</td>
<td>蓝</td>
</tr>
<tr>
<td>GREEN</td>
<td>0x00AA00</td>
<td>绿</td>
</tr>
<tr>
<td>CYAN</td>
<td>0xAAAA00</td>
<td>青</td>
</tr>
<tr>
<td>RED</td>
<td>0x0000AA</td>
<td>红</td>
</tr>
<tr>
<td>MAGENTA</td>
<td>0xAA00AA</td>
<td>紫</td>
</tr>
<tr>
<td>BROWN</td>
<td>0x0055AA</td>
<td>棕</td>
</tr>
<tr>
<td>LIGHTGRAY</td>
<td>0xAAAAAA</td>
<td>浅灰</td>
</tr>
<tr>
<td>DARKGRAY</td>
<td>0x555555</td>
<td>深灰</td>
</tr>
<tr>
<td>LIGHTBLUE</td>
<td>0xFF5555</td>
<td>亮蓝</td>
</tr>
<tr>
<td>LIGHTGREEN</td>
<td>0x55FF55</td>
<td>亮绿</td>
</tr>
<tr>
<td>LIGHTCYAN</td>
<td>0xFFFF55</td>
<td>亮青</td>
</tr>
<tr>
<td>LIGHTRED</td>
<td>0x5555FF</td>
<td>亮红</td>
</tr>
<tr>
<td>LIGHTMAGENTA</td>
<td>0xFF55FF</td>
<td>亮紫</td>
</tr>
<tr>
<td>YELLOW</td>
<td>0x55FFFF</td>
<td>黄</td>
</tr>
<tr>
<td>WHITE</td>
<td>0xFFFFFF</td>
<td>白</td>
</tr>
</tbody></table>
</li>
<li><p>16进制：</p>
<p>格式为0xbbggrr（bb&#x3D;蓝，gg&#x3D;绿，rr&#x3D;红）</p>
</li>
<li><p>RGB宏：用于将红、绿、蓝颜色分量合成RGB颜色。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">COLORREF <span class="title">RGB</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    BYTE byRed,        <span class="comment">// 颜色的红色部分，取值范围：0~255，下同</span></span></span></span><br><span class="line"><span class="params"><span class="function">    BYTE byGreen,    <span class="comment">// 颜色的绿色部分</span></span></span></span><br><span class="line"><span class="params"><span class="function">    BYTE byBlue        <span class="comment">// 颜色的蓝色部分</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HSLtoRGB，HSVtoRGB：用于将HSL&#x2F;HSV颜色空间模型转至RGB。</p>
</li>
</ol>
<h2 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h2><ol>
<li><p>物理坐标：描述设备的坐标体系，以设备左上角为原点，X轴向右为正，Y轴向下为负，度量单位为像素，不可缩放。</p>
</li>
<li><p>逻辑坐标：程序中用于绘图的坐标体系，以窗口左上角为原点，X轴向右为正，Y轴向下为正，度量单位为点。在默认情况下，逻辑坐标与物理坐标一一对应，一个逻辑点即为一个物理像素。</p>
</li>
</ol>
<h2 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h2><ol>
<li><p>“设备”指的是绘图表面。（根据功能，可以粗略理解为画板，但是其实并不仅仅是画板）</p>
</li>
<li><p>EasyX中有两种设备：默认的绘图窗口以及IMAGE对象，使用函数SetWorkingImag可更改当前用于绘图的设备，所以的绘图函数都将图形绘制在该设备上。</p>
</li>
</ol>
<hr>
<h1 id="EasyX部分功能示例"><a href="#EasyX部分功能示例" class="headerlink" title="EasyX部分功能示例"></a>EasyX部分功能示例</h1><p>只列出了我认为最有用的部分</p>
<h2 id="清屏：cleardevice"><a href="#清屏：cleardevice" class="headerlink" title="清屏：cleardevice"></a>清屏：cleardevice</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleardevice</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="设置当前设备绘图背景色：setbkcolor"><a href="#设置当前设备绘图背景色：setbkcolor" class="headerlink" title="设置当前设备绘图背景色：setbkcolor"></a>设置当前设备绘图背景色：setbkcolor</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setbkcolor</span><span class="params">(COLORREF color)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="设置当前设备图案填充和文字输出时的背景模式"><a href="#设置当前设备图案填充和文字输出时的背景模式" class="headerlink" title="设置当前设备图案填充和文字输出时的背景模式"></a>设置当前设备图案填充和文字输出时的背景模式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setbkmode</span><span class="params">(<span class="type">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>mode参数的各个值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>OPAQUE</td>
<td>背景用当前背景色填充（默认）</td>
</tr>
<tr>
<td>TRANSPARENT</td>
<td>背景透明</td>
</tr>
</tbody></table>
<h2 id="设置当前设备填充样式：setfillstyle"><a href="#设置当前设备填充样式：setfillstyle" class="headerlink" title="设置当前设备填充样式：setfillstyle"></a>设置当前设备填充样式：setfillstyle</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setfillstyle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    FILLSTYLE* pstyle</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setfillstyle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> style,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">long</span> hatch = <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    IMAGE* ppattern = <span class="literal">NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setfillstyle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    BYTE* ppattern8x8</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>pstyle</td>
<td>指向填充样式 FILLSTYLE 的指针</td>
</tr>
<tr>
<td>style</td>
<td>指定填充样式</td>
</tr>
<tr>
<td>hatch</td>
<td>指定填充图案</td>
</tr>
</tbody></table>
<p>具体内容请参照[官方文档](<a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/setfillstyle">EasyX 文档 - setfillstyle</a>)</p>
<h2 id="设置当前设备画线样式：setlinestyle"><a href="#设置当前设备画线样式：setlinestyle" class="headerlink" title="设置当前设备画线样式：setlinestyle"></a>设置当前设备画线样式：setlinestyle</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setlinestyle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> LINESTYLE* pstyle</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setlinestyle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> style,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> thickness = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DWORD *puserstyle = <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD userstylecount = <span class="number">0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>pstyle</td>
<td>指向画线样式 LINESTYLE 的指针</td>
</tr>
<tr>
<td>style</td>
<td>画线样式</td>
</tr>
<tr>
<td>thickness</td>
<td>线的宽度（单位为像素）</td>
</tr>
<tr>
<td>puserstyle</td>
<td>用户自定义样式数组</td>
</tr>
<tr>
<td>userstylecount</td>
<td>用户自定义样式数组的元素数量。</td>
</tr>
</tbody></table>
<p>具体内容请参照[官方文档](<a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/setlinestyle">EasyX 文档 - setlinestyle</a>)</p>
<h2 id="设置当前设备多边形填充模式：setpolyfillmode"><a href="#设置当前设备多边形填充模式：setpolyfillmode" class="headerlink" title="设置当前设备多边形填充模式：setpolyfillmode"></a>设置当前设备多边形填充模式：setpolyfillmode</h2><table>
<thead>
<tr>
<th>mode的各个值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ALTERNATE</td>
<td>交替填充模式（默认值）</td>
</tr>
<tr>
<td>WINDING</td>
<td>根据绘图方向填充的模式</td>
</tr>
</tbody></table>
<p>详见[官方文档](<a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/setpolyfillmode">EasyX 文档 - setpolyfillmode</a>)</p>
<hr>
<h1 id="EasyX的部分函数文档索引"><a href="#EasyX的部分函数文档索引" class="headerlink" title="EasyX的部分函数文档索引"></a>EasyX的部分函数文档索引</h1><p>这里其实就是官方文档的内容，只是给大家引个路。</p>
<h2 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h2><table>
<thead>
<tr>
<th>函数或数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/arc">arc</a></td>
<td>画椭圆弧。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/circle">circle</a></td>
<td>画无填充的圆。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/clearcircle">clearcircle</a></td>
<td>清空圆形区域。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/clearellipse">clearellipse</a></td>
<td>清空椭圆区域。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/clearpie">clearpie</a></td>
<td>清空扇形区域。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/clearpolygon">clearpolygon</a></td>
<td>清空多边形区域。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/clearrectangle">clearrectangle</a></td>
<td>清空矩形区域。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/clearroundrect">clearroundrect</a></td>
<td>清空圆角矩形区域。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/ellipse">ellipse</a></td>
<td>画无填充的椭圆。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/fillcircle">fillcircle</a></td>
<td>画有边框的填充圆。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/fillellipse">fillellipse</a></td>
<td>画有边框的填充椭圆。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/fillpie">fillpie</a></td>
<td>画有边框的填充扇形。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/fillpolygon">fillpolygon</a></td>
<td>画有边框的填充多边形。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/fillrectangle">fillrectangle</a></td>
<td>画有边框的填充矩形。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/fillroundrect">fillroundrect</a></td>
<td>画有边框的填充圆角矩形。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/floodfill">floodfill</a></td>
<td>填充区域。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/getheight">getheight</a></td>
<td>获取绘图区的高度。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/getpixel">getpixel</a></td>
<td>获取点的颜色。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/getwidth">getwidth</a></td>
<td>获取绘图区的宽度。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/line">line</a></td>
<td>画直线。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/pie">pie</a></td>
<td>画无填充的扇形。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/polybezier">polybezier</a></td>
<td>画三次方贝塞尔曲线。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/polyline">polyline</a></td>
<td>画多条连续的线。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/polygon">polygon</a></td>
<td>画无填充的多边形。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/putpixel">putpixel</a></td>
<td>画点。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/rectangle">rectangle</a></td>
<td>画无填充的矩形。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/roundrect">roundrect</a></td>
<td>画无填充的圆角矩形。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/solidcircle">solidcircle</a></td>
<td>画无边框的填充圆。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/solidellipse">solidellipse</a></td>
<td>画无边框的填充椭圆。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/solidpie">solidpie</a></td>
<td>画无边框的填充扇形。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/solidpolygon">solidpolygon</a></td>
<td>画无边框的填充多边形。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/solidrectangle">solidrectangle</a></td>
<td>画无边框的填充矩形。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/solidroundrect">solidroundrect</a></td>
<td>画无边框的填充圆角矩形。</td>
</tr>
</tbody></table>
<h2 id="文字输出"><a href="#文字输出" class="headerlink" title="文字输出"></a>文字输出</h2><table>
<thead>
<tr>
<th>函数或数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/gettextcolor">gettextcolor</a></td>
<td>获取当前文字颜色。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/gettextstyle">gettextstyle</a></td>
<td>获取当前文字样式。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/LOGFONT">LOGFONT</a></td>
<td>文字样式的结构体。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/outtextxy">outtextxy</a></td>
<td>在指定位置输出字符串。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/drawtext">drawtext</a></td>
<td>在指定区域内以指定格式输出字符串。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/settextcolor">settextcolor</a></td>
<td>设置当前文字颜色。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/settextstyle">settextstyle</a></td>
<td>设置当前文字样式。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/textheight">textheight</a></td>
<td>获取字符串实际占用的像素高度。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/textwidth">textwidth</a></td>
<td>获取字符串实际占用的像素宽度。</td>
</tr>
</tbody></table>
<h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><table>
<thead>
<tr>
<th>函数或数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/IMAGE">IMAGE</a></td>
<td>保存图像的对象。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/loadimage">loadimage</a></td>
<td>读取图片文件。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/saveimage">saveimage</a></td>
<td>保存绘图内容至图片文件。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/getimage">getimage</a></td>
<td>从当前绘图设备中获取图像。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/putimage">putimage</a></td>
<td>在当前绘图设备上绘制指定图像。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/GetWorkingImage">GetWorkingImage</a></td>
<td>获取指向当前绘图设备的指针。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/rotateimage">rotateimage</a></td>
<td>旋转 IMAGE 中的绘图内容。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/SetWorkingImage">SetWorkingImage</a></td>
<td>设定当前绘图设备。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/Resize">Resize</a></td>
<td>调整指定绘图设备的尺寸。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/GetImageBuffer">GetImageBuffer</a></td>
<td>获取绘图设备的显示缓冲区指针。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/GetImageHDC">GetImageHDC</a></td>
<td>获取绘图设备句柄。</td>
</tr>
</tbody></table>
<h2 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h2><table>
<thead>
<tr>
<th>函数或数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/exmessage">ExMessage</a></td>
<td>消息结构体。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/flushmessage">flushmessage</a></td>
<td>清空消息缓冲区。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/getmessage">getmessage</a></td>
<td>获取一个消息。如果当前消息缓冲区中没有，就一直等待。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/peekmessage">peekmessage</a></td>
<td>获取一个消息，并立即返回。</td>
</tr>
</tbody></table>
<h2 id="连续绘图"><a href="#连续绘图" class="headerlink" title="连续绘图"></a>连续绘图</h2><p>实际上貌似是启用了双缓冲，可以有效解决连续绘图时的闪烁问题，使用如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BeginBatchDraw</span>();</span><br><span class="line"><span class="comment">// 绘制你的内容...</span></span><br><span class="line"><span class="built_in">EndBatchDraw</span>();</span><br></pre></td></tr></table></figure>

<p>EndBatchDraw会将绘制的内容输出，使用FlushBatchDraw能达到同样效果。</p>
<h2 id="获取窗口句柄"><a href="#获取窗口句柄" class="headerlink" title="获取窗口句柄"></a>获取窗口句柄</h2><p>EasyX提供了GetHWnd函数以获得当前窗口的句柄，由此你可以使用Windows API对窗口进行进一步的操作，原型如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HWND <span class="title">GetHWnd</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="输入对话框"><a href="#输入对话框" class="headerlink" title="输入对话框"></a>输入对话框</h2><p>EasyX提供了InputBox函数用于以对话框形式获取用户输入，原型如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InputBox</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPTSTR    pString,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>        nMaxCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR    pPrompt = <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR    pTitle = <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR    pDefault = <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>        width = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>        height = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span>    bHideCancelBtn = <span class="literal">true</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="关于使用EasyX构建一个简单的游戏简述"><a href="#关于使用EasyX构建一个简单的游戏简述" class="headerlink" title="关于使用EasyX构建一个简单的游戏简述"></a>关于使用EasyX构建一个简单的游戏简述</h1><ol>
<li><p>EasyX仅仅是一个绘图库，它只能完成图形的绘制以及鼠标信息的捕获任务，要构建一个完整的游戏，所需要的不仅仅是EasyX。</p>
</li>
<li><p>VC&#x2F;VS中提供了conio.h，能实现非阻塞式的键盘监听（非全局）。</p>
</li>
<li><p>Windows API中的mmsystem.h（需要链接winmm.lib）提供了一套简单的音乐播放功能。</p>
</li>
<li><p>如果你的游戏中的对象是动态的（比如数量不确定的敌人），那么你需要用到堆内存分配，以及一些用于管理堆内存的数据结构。</p>
</li>
<li><p>我之前用EasyX写了<a target="_blank" rel="noopener" href="https://github.com/IAKSH/easySnake">一个游戏</a>，有兴趣可以看看，但是代码很乱，因为我懒。</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/intro">EasyX 文档 - 基本说明</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/19/%E5%85%B3%E4%BA%8Emath-h%E7%9A%84%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/19/%E5%85%B3%E4%BA%8Emath-h%E7%9A%84%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">关于math.h的笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-19 01:21:52 / 修改时间：02:12:27" itemprop="dateCreated datePublished" datetime="2022-08-19T01:21:52+08:00">2022-08-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>闲话少叙，直接来吧。 </p>
<h1 id="math-h"><a href="#math-h" class="headerlink" title="math.h"></a>math.h</h1><p>    math.h作为C标准库的一部分，提供了部分数学运算函数以及数学常量。其中绝大部分函数都只在头文件内完成声明和定义，仅有部分需要链接数学库（linux）。</p>
<p>    math.h中提供的函数的返回类型和参数类型几乎都是double。</p>
<p>    作为标准库的一部分，为了实现兼容，math.h的内容非常复杂，很难一一列举，<strong>我仅仅举出了部分内容</strong>，仅供参考。</p>
<h1 id="宏常量"><a href="#宏常量" class="headerlink" title="宏常量"></a>宏常量</h1><ol>
<li><p>INFINITY : 正无穷，返回一个 float。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_ISOC99</span></span><br><span class="line"><span class="comment">/* IEEE positive infinity.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __GNUC_PREREQ (3, 3)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> INFINITY (__builtin_inff ())</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> INFINITY HUGE_VALF</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>NAN ：非数字（Not-A-Number)，返回一个float。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IEEE Not A Number.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __GNUC_PREREQ (3, 3)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> NAN (__builtin_nanf (<span class="string">&quot;&quot;</span>))</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="comment">/* This will raise an &quot;invalid&quot; exception outside static initializers,</span></span><br><span class="line"><span class="comment">   but is the best that can be done in ISO C while remaining a</span></span><br><span class="line"><span class="comment">   constant expression.  */</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> NAN (0.0f / 0.0f)</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __USE_ISOC99 */</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>   <em>实际上还有很多宏，无法完全列举，请查阅标准库头文件。</em> </p>
<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><ol>
<li><p>float_t : （当前系统）最有效执行 float 运算的类型，宽度至少与 float 一样。</p>
</li>
<li><p>double_t : （当前系统）最有效执行 double 运算的类型，宽度至少与 double 一样。</p>
<p><em>可能存在更多类型定义，具体视实现而定</em></p>
</li>
</ol>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ol>
<li><p>三角函数</p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>double acos(double x)</td>
<td>反余弦（x为弧度制，下同）</td>
</tr>
<tr>
<td>double asin(double x)</td>
<td>反正弦</td>
</tr>
<tr>
<td>double atan(double x)</td>
<td>反正切</td>
</tr>
<tr>
<td>double atan2(double y, double x)</td>
<td>y&#x2F;x 的反正切，y 和 x 的符号决定象限</td>
</tr>
<tr>
<td>double cos(double x)</td>
<td>余弦</td>
</tr>
<tr>
<td>double sin(double x)</td>
<td>正弦</td>
</tr>
</tbody></table>
</li>
<li><p>双曲函数</p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>double cosh(double x)</td>
<td>双曲余弦</td>
</tr>
<tr>
<td>double sinh(double x)</td>
<td>双曲正弦</td>
</tr>
<tr>
<td>double tanh(double x)</td>
<td>双曲正切</td>
</tr>
</tbody></table>
</li>
<li><p>指数,对数函数</p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>double exp(double x)</td>
<td>自然数e 的 x 次幂</td>
</tr>
<tr>
<td>double log(double x)</td>
<td>x 的自然对数</td>
</tr>
<tr>
<td>double log10(double x)</td>
<td>x 的常用对数</td>
</tr>
<tr>
<td>double sqrt(double x)</td>
<td>平方根</td>
</tr>
<tr>
<td>double pow(double x, double y)</td>
<td>x 的 y 次幂</td>
</tr>
<tr>
<td>double modf(double x, double *integer)</td>
<td>x 的常用对数</td>
</tr>
<tr>
<td>double log(double x)</td>
<td>x 的自然对数</td>
</tr>
<tr>
<td>double ldexp(double x, int exponent)</td>
<td>x 乘以 2 的 exponent 次幂</td>
</tr>
</tbody></table>
</li>
<li><p>其他</p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>double floor(double x)</td>
<td>小于或等于 x 的最大的整数值。</td>
</tr>
<tr>
<td>double fmod(double x, double y)</td>
<td>x 除以 y 的余数。</td>
</tr>
<tr>
<td>double fabs(double x)</td>
<td>绝对值</td>
</tr>
<tr>
<td>double ceil(double x)</td>
<td>大于或等于 x 的最小的整数值</td>
</tr>
<tr>
<td>double frexp(double x, int *exponent)</td>
<td>把浮点数 x 分解成尾数和指数。返回值是尾数，并将指数存入 exponent 中。所得的值是 x &#x3D; mantissa * 2 ^ exponent</td>
</tr>
</tbody></table>
</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol>
<li><p>math.h中进行了庞大的编译器判断，以使用在当前平台速度最快的数据类型。</p>
</li>
<li><p>math.h是十分重要的，它补充了C&#x2F;C++相比于更新的语言在运算符上的不足，并且提供了一套简单易用，且通用，高效的数学运算。</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>glibc标准库头文件</p>
<p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-lib-math.h.md">标准库 - math.h - 《阮一峰《C 语言教程》》 - 书栈网 · BookStack</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-standard-library-math-h.html">C 标准库 – &lt;math.h&gt; | 菜鸟教程 (runoob.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/math.h/10991856">math.h_百度百科 (baidu.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/18/%E8%AE%B0%E4%B8%80%E6%AC%A1C%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%9A%E9%87%8D%E5%AE%9A%E4%B9%89-multiple-definition-%E6%8A%A5%E9%94%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/18/%E8%AE%B0%E4%B8%80%E6%AC%A1C%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%9A%E9%87%8D%E5%AE%9A%E4%B9%89-multiple-definition-%E6%8A%A5%E9%94%99/" class="post-title-link" itemprop="url">记一次C中全局变量的多重定义(multiple definition)报错</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-18 23:32:54 / 修改时间：23:33:51" itemprop="dateCreated datePublished" datetime="2022-08-18T23:32:54+08:00">2022-08-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="记一次C中全局变量的多重定义-multiple-definition-报错"><a href="#记一次C中全局变量的多重定义-multiple-definition-报错" class="headerlink" title="记一次C中全局变量的多重定义(multiple definition)报错"></a>记一次C中全局变量的多重定义(multiple definition)报错</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>我在一个头文件里定义了一个全局bool（stdbool.h里的那个)，然后在两个源文件中include了这个头文件，在编译时gcc报错multiple definition of  ‘（省略）’</p>
<h2 id="修复一个bug，获得更多bug"><a href="#修复一个bug，获得更多bug" class="headerlink" title="修复一个bug，获得更多bug"></a>修复一个bug，获得更多bug</h2><p>由于太久没有温习，我最初尝试给bool值的声明语句添加static。</p>
<p>这确实解决了问题，但是在头文件中用static定义的变量在每次include时会产生不同的对象。每个include此头文件的文件作用域中都会有一个互不干扰的同名变量。</p>
<p>我的这次操作修复了一个bug，产生了更多bug，并导致我进行了长达1分钟的排查。</p>
<h2 id="正确解法"><a href="#正确解法" class="headerlink" title="正确解法"></a>正确解法</h2><p>不要在头文件里定义全局变量，这是导致多重定义的直接原因。</p>
<p>如果你不得不这么做，请在头文件中使用extern声明变量，随后在某个源文件内声明。</p>
<h2 id="不解"><a href="#不解" class="headerlink" title="不解"></a>不解</h2><p>道理我都明白，但是，为什么已经加了#pragma once，还是多重定义了。<br>且进一步测试表明，#ifndef + #define + #endif也无法解决此问题。</p>
<h2 id="对上述不解的探究"><a href="#对上述不解的探究" class="headerlink" title="对上述不解的探究"></a>对上述不解的探究</h2><p>我使用gcc -E获取了include上述头文件的源码经过预处理后的文本。</p>
<p>然后…然后啥也没看出来。</p>
<p><em>（未完待续）</em><br><em>（也许吧）</em></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/15/C%E4%B8%AD%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E6%97%B6%E5%BF%BD%E7%95%A5%E6%B5%AE%E7%82%B9%E6%95%B0%E5%A4%9A%E4%BD%99%E7%9A%840/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/15/C%E4%B8%AD%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E6%97%B6%E5%BF%BD%E7%95%A5%E6%B5%AE%E7%82%B9%E6%95%B0%E5%A4%9A%E4%BD%99%E7%9A%840/" class="post-title-link" itemprop="url">C中格式化输出时忽略浮点数多余的0</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-15 23:32:02" itemprop="dateCreated datePublished" datetime="2022-08-15T23:32:02+08:00">2022-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-16 01:29:41" itemprop="dateModified" datetime="2022-08-16T01:29:41+08:00">2022-08-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日刷题，居然被这破玩意儿难住了，搞了半个多小时弄了个神必算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">3</span>][<span class="number">128</span>];</span><br><span class="line">    <span class="type">float</span> row[<span class="number">3</span>];</span><br><span class="line">    <span class="type">float</span> buffer = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buffer);</span><br><span class="line">        <span class="built_in">strcpy</span>(input[i], buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">2</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(atof(input[j]) &lt; atof(input[j+<span class="number">1</span>]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">                <span class="built_in">strcpy</span>(buffer, input[j+<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">strcpy</span>(input[j+<span class="number">1</span>], input[j]);</span><br><span class="line">                <span class="built_in">strcpy</span>(input[j], buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>,input[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    putc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说出来你可能不信，我当时甚至想拿union来搞位操作判断是几位小数。</p>
<p>后来发现只要用%g就可以忽略浮点数多余的0不输出了。</p>
<p>使用如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%g\n&quot;</span>,<span class="number">114.51400f</span>);  <span class="comment">//output: 114.514</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(buffer,<span class="string">&quot;%g&quot;</span>,<span class="number">114.51400f</span>);</span><br><span class="line"><span class="built_in">puts</span>(buffer);               <span class="comment">//output: 114.514</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">IAKSH</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/IAKSH" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;IAKSH" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:askzrj21@163.com" title="E-Mail → mailto:askzrj21@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">IAKSH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
