<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"iaksh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hello world!">
<meta property="og:url" content="https://iaksh.github.io/page/2/index.html">
<meta property="og:site_name" content="Hello world!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="IAKSH">
<meta property="article:tag" content="IAKSH">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://iaksh.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hello world!</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hello world!</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/15/%E5%9C%A8vscode%E4%B8%8A%E6%90%AD%E5%BB%BAWSL2%E4%B8%8B%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/15/%E5%9C%A8vscode%E4%B8%8A%E6%90%AD%E5%BB%BAWSL2%E4%B8%8B%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">在vscode上搭建WSL2下的C语言开发环境</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-15 21:02:39" itemprop="dateCreated datePublished" datetime="2022-08-15T21:02:39+08:00">2022-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-16 23:38:11" itemprop="dateModified" datetime="2022-09-16T23:38:11+08:00">2022-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>由于Visua Studio仅有C++编译器，且其对C标准库改动过大，我的C程序开发主要在WSL2上进行。<br>这篇文档将会引导你在Windows10&#x2F;11上使用vscode连接本地WSL2进行Linux环境下的C程序开发。<br>如果你尚未部署WSL2，请翻阅<a href="https://iaksh.github.io/2022/08/11/WSL2%E4%B8%8EWSLg%E7%9A%84%E9%83%A8%E7%BD%B2/">这篇文章</a></p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>我没有使用微软官方的C&#x2F;C++插件，因为它从某种角度来说太糟糕了。<br>这也意味着这套开发环境能够在vscodium上正常部署。</p>
<h1 id="我选用的技术栈"><a href="#我选用的技术栈" class="headerlink" title="我选用的技术栈"></a>我选用的技术栈</h1><table>
<thead>
<tr>
<th>项目</th>
<th>参数</th>
</tr>
</thead>
<tbody><tr>
<td>文本编辑器</td>
<td>Visual Studio Code</td>
</tr>
<tr>
<td>编译器</td>
<td>gcc</td>
</tr>
<tr>
<td>调试器</td>
<td>gdb</td>
</tr>
<tr>
<td>构建工具</td>
<td>CMake + Makefile（可替换为Ninja）</td>
</tr>
<tr>
<td>代码补全</td>
<td>clangd</td>
</tr>
<tr>
<td>代码格式化</td>
<td>clang-format</td>
</tr>
</tbody></table>
<p><em>（其实你也可以选用全套LLVM&#x2F;Clang工具链，但依然无法摆脱gcc）</em></p>
<h1 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h1><h2 id="在Windows上为vscode安装插件"><a href="#在Windows上为vscode安装插件" class="headerlink" title="在Windows上为vscode安装插件"></a>在Windows上为vscode安装插件</h2><p><a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl">Remote - WSL</a></p>
<h2 id="在WSL2上安装C工具链"><a href="#在WSL2上安装C工具链" class="headerlink" title="在WSL2上安装C工具链"></a>在WSL2上安装C工具链</h2><ol>
<li><p>安装gcc工具链以及CMake，git<br><em>（部分发行版的部分安装策略中是包含了这一工具链的，若有，无视这条。）</em><br>Debian系：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc gdb make cmake git</span><br></pre></td></tr></table></figure>
<p>Redhat系：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc gdb make cmake git</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装cland和clang-format<br>注：这一步实际上<strong>会安装LLVM&#x2F;Clang工具链</strong><br>Debian系：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install clangd clang-format</span><br></pre></td></tr></table></figure>
<p>Redhat系：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install clang-tools-extra</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="使用vscode在WSL2中安装插件"><a href="#使用vscode在WSL2中安装插件" class="headerlink" title="使用vscode在WSL2中安装插件"></a>使用vscode在WSL2中安装插件</h2><p>在Windows上使用vscode的Remote - WSL插件连接到WSL2后，安装以下插件至WSL2：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd">clangd</a></li>
<li><a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=coolchyni.beyond-debug">GDB Debugger - Beyond</a></li>
<li><a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=twxs.cmake">CMake</a></li>
<li><a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools">CMake Tools</a></li>
</ol>
<h1 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h1><ol>
<li><p>快速创建一个CMake项目：<br>连接到WSL2后按ctrl+shift+p，在弹出的输入框中输入CMake: Quick Start然后回车。<br>期间需要选择项目类型（库or可执行），项目名称，以及编译工具链。</p>
</li>
<li><p>调用clang-tidy：<br>clang-format的功能被集成到了clangd插件中，在编辑器中右键选择格式化文档即可。</p>
</li>
<li><p>Debug：<br>打断点之类的操作流程没有变化，但是在开始Debug之前，你需要手动指定可执行文件路径。<br>除非CMakeLists.txt里指定了别的构建位置，可执行文件一般会生成在项目的build&#x2F;目录中。<br>第一次运行Debug时，请点击vscode左侧的“运行和调试”选项卡，点击“创建 launch.json文件”，调试器选择“GDB(Beyond)”。<br>将”program”键的值该为你的可执行文件路径，即可正常Debug。<br>另：你可以使用${workspaceRoot}（vscode提供的宏）来匹配路径，以保证项目文件的可移植性。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/15/%E5%AF%B9%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%B7%B7%E5%90%88%E8%BE%93%E5%87%BA%E7%9A%84%E6%8E%A2%E7%A9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/15/%E5%AF%B9%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%B7%B7%E5%90%88%E8%BE%93%E5%87%BA%E7%9A%84%E6%8E%A2%E7%A9%B6/" class="post-title-link" itemprop="url">对笔记本混合输出的探究</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-15 01:00:36" itemprop="dateCreated datePublished" datetime="2022-08-15T01:00:36+08:00">2022-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-16 23:37:54" itemprop="dateModified" datetime="2022-09-16T23:37:54+08:00">2022-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  这篇文章并没有写完，有待更新。</p>
<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>  几日前购置了一台游戏本，却无心拿它去玩什么游戏了。<br>  但又碍于发热过高，于是想到开启混合输出是否能在日常使用中平衡GPU负载，降低功耗。</p>
<h1 id="测试机器"><a href="#测试机器" class="headerlink" title="测试机器"></a>测试机器</h1><p>  考虑到某些可能存在的隐患，我不想直接写出笔记本型号，这里列出其大致参数。</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>参数</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>CPU</td>
<td>Intel Core i7 12700H</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>GPU0</td>
<td>Iris XE</td>
<td>96eu</td>
</tr>
<tr>
<td>GPU1</td>
<td>Nvidia GeForce RTX 3060 Laptop</td>
<td>140W</td>
</tr>
<tr>
<td>电源适配器</td>
<td>230W</td>
<td>N&#x2F;A</td>
</tr>
</tbody></table>
<h1 id="测试项目"><a href="#测试项目" class="headerlink" title="测试项目"></a>测试项目</h1><p>  使用Windows 11 “电影和电视”程序播放 SONY DEMO 4K 演示片 ( 2160 X 3840 60fps )<br>  其他的，我暂时懒得弄了，下次继续。</p>
<h1 id="功耗检测软件"><a href="#功耗检测软件" class="headerlink" title="功耗检测软件"></a>功耗检测软件</h1><p>  使用HWMonitor(x64)监控CPU GT Power。<br>  使用Nvidia Experience监控RTX 3060 Laptop功耗。</p>
<h1 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h1><p>  混合输出：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>最大功耗</th>
<th>平均功耗</th>
<th>平均使用率</th>
</tr>
</thead>
<tbody><tr>
<td>CPU Powers</td>
<td>20.36W</td>
<td>10.5W</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>CPU GT Powers</td>
<td>3.35W</td>
<td>1.5W</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>Iris XE (96EU)</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
<td>50%</td>
</tr>
<tr>
<td>Nvidia GeForce RTX 3060 Laptop</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
<td>0%</td>
</tr>
</tbody></table>
<p>  独显直连</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>最大功耗</th>
<th>平均功耗</th>
<th>平均使用率</th>
</tr>
</thead>
<tbody><tr>
<td>CPU Powers</td>
<td>20.18W</td>
<td>7.3W</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>Nvidia GeForce RTX 3060 Laptop</td>
<td>24W</td>
<td>21W</td>
<td>38%</td>
</tr>
</tbody></table>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>  在当前实验环境下，混合输出确实能减少观看4k 60fps hdr影片时的功耗，由此类推，在日常使用中，混合输出较独显直连更加省电，<em>理论上</em>能减少发热。<br>  但当前测试环境中独显为使用三星8nm工艺的RTX 3060 Laptop，考虑到三星工艺糟糕的能效表现，<strong>此次实验结果在Nvidia 20&#x2F;10系显卡上的不一定适用</strong>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/14/%E5%85%B3%E4%BA%8Estring-h%E7%9A%84%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/14/%E5%85%B3%E4%BA%8Estring-h%E7%9A%84%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">关于string.h的笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-14 22:13:43" itemprop="dateCreated datePublished" datetime="2022-08-14T22:13:43+08:00">2022-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-15 01:23:26" itemprop="dateModified" datetime="2022-08-15T01:23:26+08:00">2022-08-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>  近日在LeetCode上刷题，发现string.h内容忘差不多了，随手记一记（指复制粘贴）</p>
<h1 id="string-h定义的类型"><a href="#string-h定义的类型" class="headerlink" title="string.h定义的类型"></a>string.h定义的类型</h1><h2 id="size-t"><a href="#size-t" class="headerlink" title="size_t"></a>size_t</h2><p>  其实就是个无符号整数（具体类型与编译器实现相关）。同时也是sizeof关键字所返回的类型。</p>
<h1 id="string-h定义的宏"><a href="#string-h定义的宏" class="headerlink" title="string.h定义的宏"></a>string.h定义的宏</h1><h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h2><p>  不用再解释了吧。<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br></pre></td></tr></table></figure></p>
<h1 id="string-h定义的函数"><a href="#string-h定义的函数" class="headerlink" title="string.h定义的函数"></a>string.h定义的函数</h1><h2 id="mem系"><a href="#mem系" class="headerlink" title="mem系"></a>mem系</h2><h3 id="memchr"><a href="#memchr" class="headerlink" title="memchr"></a>memchr</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memchr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>
<p>  返回 str 所指向的内存中前 n 个字节里第一次出现的（无符号）字符 c 的指针。</p>
<hr>
<h3 id="memcmp"><a href="#memcmp" class="headerlink" title="memcmp"></a>memcmp</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>
<p>  比较从 str1 开始的 n 个字节与从 str2 开始的 n 个字节。<br>  <em>(cmp -&gt; compare)</em></p>
<hr>
<h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>
<p>  将以 src 为起点的 n 个字节复制到以 dest 为起点的 n 个字节。</p>
<hr>
<h3 id="memmove"><a href="#memmove" class="headerlink" title="memmove"></a>memmove</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memmove</span><span class="params">(<span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>
<p>  类似memcpy，但更安全。</p>
<blockquote>
<p>如果目标区域和源区域有重叠的话，memmove() 能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，复制后源区域的内容会被更改。(来源：<a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-memmove.html">菜鸟教程</a>)</p>
</blockquote>
<hr>
<h3 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>
<p>  设置以 str 为起点，位移 +n 的地址的值为 c。</p>
<hr>
<h2 id="str系"><a href="#str系" class="headerlink" title="str系"></a>str系</h2><h3 id="strcat"><a href="#strcat" class="headerlink" title="strcat"></a>strcat</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span><br></pre></td></tr></table></figure>
<p>  把src所指向的字符串接到dest所指向的字符串的末尾。<br>  返回一个指向最终的目标字符串 dest 的指针</p>
<hr>
<h3 id="strncat"><a href="#strncat" class="headerlink" title="strncat"></a>strncat</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>
<p>  将 scr 所指向的字符串的前 n 个字符复制到 dest 所指向的字符串的末尾。</p>
<hr>
<h3 id="strchr"><a href="#strchr" class="headerlink" title="strchr"></a>strchr</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> c)</span></span><br></pre></td></tr></table></figure>
<p>  搜索 str 所指向的字符串中第一次出现的（无符号）字符 c 并返回其指针。</p>
<hr>
<h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span><br></pre></td></tr></table></figure>
<p>  比较 str1 ， str2 两者所指向的字符串的内容。</p>
<hr>
<h3 id="strncmp"><a href="#strncmp" class="headerlink" title="strncmp"></a>strncmp</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>
<p>  比较 str1 ， str2 两者所指向的字符串的内容，但只比较前 n 个字符。</p>
<hr>
<h3 id="strcoll"><a href="#strcoll" class="headerlink" title="strcoll"></a>strcoll</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcoll</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span><br></pre></td></tr></table></figure>
<p>  与Localization support有关，暂时无法理解。</p>
<blockquote>
<p>把 str1 和 str2 进行比较，结果取决于 LC_COLLATE 的位置设置。</p>
</blockquote>
<hr>
<h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span><br></pre></td></tr></table></figure>
<p>  将 src 所指向的字符串复制到 dest。</p>
<hr>
<h3 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy"></a>strncpy</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>
<p>  将 src 所指向的字符串复制到 dest，但只复制前 n 个字符。</p>
<hr>
<h3 id="strcspn"><a href="#strcspn" class="headerlink" title="strcspn"></a>strcspn</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strcspn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span><br></pre></td></tr></table></figure>
<p>  返回 str1 中第几个字符与 str2 的某一个字符相同。</p>
<h3 id="strerror"><a href="#strerror" class="headerlink" title="strerror"></a>strerror</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errnum)</span></span><br></pre></td></tr></table></figure>
<p>  起初我不太理解，但看到这行：</p>
<blockquote>
<p>C 库函数 char *strerror(int errnum) 从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。strerror 生成的错误字符串取决于开发平台和编译器。（<a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-strerror.html">菜鸟教程</a>)</p>
</blockquote>
<p>  似乎是配合errno.h获取最近的报错描述字符串的。<br>  使用列如下。<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">      FILE *fp;</span><br><span class="line">      fp = fopen(<span class="string">&quot;file.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>( fp == <span class="literal">NULL</span> ) </span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：Error: No such file or directory</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br></pre></td></tr></table></figure>
<p>  返回 str 所指向的字符串的长度（直到但不包括\0）。</p>
<hr>
<h3 id="strpbrk"><a href="#strpbrk" class="headerlink" title="strpbrk"></a>strpbrk</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strpbrk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，则停止检验，并返回该字符位置。</p>
</blockquote>
<hr>
<h3 id="strrchr"><a href="#strrchr" class="headerlink" title="strrchr"></a>strrchr</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strrchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> c)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在参数 str 所指向的字符串中搜索<strong>最后一次</strong>出现字符 c（一个无符号字符）的位置。</p>
</blockquote>
<hr>
<h3 id="strspn"><a href="#strspn" class="headerlink" title="strspn"></a>strspn</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strspn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。</p>
</blockquote>
<hr>
<h3 id="strstr"><a href="#strstr" class="headerlink" title="strstr"></a>strstr</h3><p>  <del>所以这是什么鬼名字</del><br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *haystack, <span class="type">const</span> <span class="type">char</span> *needle)</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在字符串 haystack 中查找第一次出现字符串 needle（不包含空结束字符）的位置。</p>
</blockquote>
<hr>
<h3 id="strtok"><a href="#strtok" class="headerlink" title="strtok"></a>strtok</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strtok</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *delim)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>分解字符串 str 为一组字符串，delim 为分隔符。</p>
</blockquote>
<hr>
<h3 id="strxfrm"><a href="#strxfrm" class="headerlink" title="strxfrm"></a>strxfrm</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strxfrm</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>
<p>  也与Localization support有关，还是无法理解。</p>
<blockquote>
<p>根据程序当前的区域选项中的 LC_COLLATE 来转换字符串 src 的前 n 个字符，并把它们放置在字符串 dest 中。</p>
</blockquote>
<h1 id="末"><a href="#末" class="headerlink" title="末"></a>末</h1><p>  string.h中同时包括了memxxx和strxxx函数，很明显，这是因为char既是byte。一般来说，char的二进制占8位，共计1字节。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-standard-library-string-h.html">菜鸟教程 : C 标准库 - &lt;string.h&gt;</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/chapter/10305">腾讯云开发者社区开发者手册 : 本地化支持 | Localization support</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/13/%E5%9C%A8Linux%E4%B8%AD%E4%BD%BF%E7%94%A8tar%E7%AE%A1%E7%90%86%E5%BD%92%E6%A1%A3%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/13/%E5%9C%A8Linux%E4%B8%AD%E4%BD%BF%E7%94%A8tar%E7%AE%A1%E7%90%86%E5%BD%92%E6%A1%A3%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">在Linux中使用tar管理归档文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-13 11:37:01 / 修改时间：13:00:27" itemprop="dateCreated datePublished" datetime="2022-08-13T11:37:01+08:00">2022-08-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>  近来我在云服务器上搭建潜渊症的游戏服务器，时常需要从本地打包文件上传以及从云端打包然后传回文件。<br>  我发现.zip虽然在Windows以及Linux上都通用，但却无法保留文件属性，相较之下，在Linux上，使用tar将文件打包为.tar.gz进行归档是个更好的选择。</p>
<h1 id="什么是tar命令"><a href="#什么是tar命令" class="headerlink" title="什么是tar命令"></a>什么是tar命令</h1><p>  tar命令（英文全拼：tape archive ），用于备份文件。<br>  tar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。</p>
<h1 id="最常用的三组tar命令"><a href="#最常用的三组tar命令" class="headerlink" title="最常用的三组tar命令"></a>最常用的三组tar命令</h1><h2 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h2>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf test.tar.gz a.c   //压缩 a.c文件为test.tar.gz</span><br></pre></td></tr></table></figure>
<p>  参数解释：</p>
<table>
<thead>
<tr>
<th>短参</th>
<th>长参</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>–create</td>
<td>建立新的备份文件</td>
</tr>
<tr>
<td>-z</td>
<td>–gzip或–ungzip</td>
<td>通过gzip指令处理备份文件</td>
</tr>
<tr>
<td>-v</td>
<td>–verbose</td>
<td>显示指令执行过程</td>
</tr>
<tr>
<td>-f xxx</td>
<td>–file&#x3D;xxx</td>
<td>指定备份文件</td>
</tr>
</tbody></table>
<h2 id="列出压缩文件的内容"><a href="#列出压缩文件的内容" class="headerlink" title="列出压缩文件的内容"></a>列出压缩文件的内容</h2>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tzvf test.tar.gz </span><br></pre></td></tr></table></figure>
<p>  参数解释：</p>
<table>
<thead>
<tr>
<th>短参</th>
<th>长参</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>-t</td>
<td>–list</td>
<td>列出备份文件的内容</td>
</tr>
<tr>
<td>-z</td>
<td>–gzip或–ungzip</td>
<td>通过gzip指令处理备份文件</td>
</tr>
<tr>
<td>-v</td>
<td>–verbose</td>
<td>显示指令执行过程</td>
</tr>
<tr>
<td>-f xxx</td>
<td>–file&#x3D;xxx</td>
<td>指定备份文件</td>
</tr>
</tbody></table>
<h2 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h2>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf test.tar.gz </span><br></pre></td></tr></table></figure>
<p>  参数解释：</p>
<table>
<thead>
<tr>
<th>短参</th>
<th>长参</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>-x</td>
<td>–extract或–get</td>
<td>从备份文件中还原文件</td>
</tr>
<tr>
<td>-z</td>
<td>–gzip或–ungzip</td>
<td>通过gzip指令处理备份文件</td>
</tr>
<tr>
<td>-v</td>
<td>–verbose</td>
<td>显示指令执行过程</td>
</tr>
<tr>
<td>-f xxx</td>
<td>–file&#x3D;xxx</td>
<td>指定备份文件</td>
</tr>
</tbody></table>
<h1 id="其他一些可能有用的参数（部分）"><a href="#其他一些可能有用的参数（部分）" class="headerlink" title="其他一些可能有用的参数（部分）"></a>其他一些可能有用的参数（部分）</h1><table>
<thead>
<tr>
<th>短参</th>
<th>长参</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>-A</td>
<td>–catenate</td>
<td>新增文件到已存在的备份文件</td>
</tr>
<tr>
<td>-d</td>
<td>–diff或–compare</td>
<td>对比备份文件内和文件系统上的文件的差异</td>
</tr>
<tr>
<td>-k</td>
<td>–keep-old-files</td>
<td>解开备份文件时，不覆盖已有的文件</td>
</tr>
<tr>
<td>-m</td>
<td>–modification-time</td>
<td>还原文件时，不变更文件的更改时间</td>
</tr>
<tr>
<td>-N&lt;日期格式&gt;</td>
<td>–newer&#x3D;&lt;日期时间&gt;</td>
<td>只将较指定日期更新的文件保存到备份文件里</td>
</tr>
<tr>
<td>-O</td>
<td>–stdout</td>
<td>把从备份文件里还原的文件输出到标准输出设备</td>
</tr>
<tr>
<td>-p</td>
<td>–same-permissions</td>
<td>用原来的文件权限还原文件</td>
</tr>
<tr>
<td>-r</td>
<td>–append</td>
<td>新增文件到已存在的备份文件的结尾部分</td>
</tr>
<tr>
<td>-u</td>
<td>–update</td>
<td>仅置换较备份文件内的文件更新的文件</td>
</tr>
<tr>
<td>N&#x2F;A</td>
<td>–ignore-failed-read</td>
<td>忽略数据读取错误，不中断程序的执行</td>
</tr>
</tbody></table>
<h1 id="我的一些感想"><a href="#我的一些感想" class="headerlink" title="我的一些感想"></a>我的一些感想</h1><p>不只是tar，Linux上的很多工具都给我一种感觉。在Windows上需要某个第三方软件来完成的事，对Linux上的工具而言只是它们最基础的功能。Linux上的这些工具能很方便的嵌入自动化脚本中，整个系统就像是一个巨大的程序库，共给shell调用。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-tar.html">菜鸟教程-Linux tar 命令</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/12/Dev-C-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/12/Dev-C-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Dev-C++的安装和使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-12 15:45:16" itemprop="dateCreated datePublished" datetime="2022-08-12T15:45:16+08:00">2022-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-16 23:37:32" itemprop="dateModified" datetime="2022-09-16T23:37:32+08:00">2022-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>  其实，我有软件洁癖。但是学校好像要求要用Dev-C++，所以我在虚拟机里进行了配置，并写下了这篇博文。<br>  <del>（后日谈：后来我发现Dev-C++还是有几分优雅的，于是迅速在物理机上整了个）</del><br>  我对Dev-C++这样老掉牙且有先天缺陷的IDE一向是嗤之以鼻的，但看了一些文章以后，这样的看法似乎有一些改观了。<br>  Dev-C++也许不是一个趁手的工具，但它不失为一个合适的教具。</p>
<h1 id="什么是Dev-C"><a href="#什么是Dev-C" class="headerlink" title="什么是Dev-C++"></a>什么是Dev-C++</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>  Dev-C++是以Delphi编写（存疑）的，运行在Windows上的，以MinGW-W64（或TDM-GCC）为后端的<strong>基于GPL协议开源</strong>的C&#x2F;C++集成开发环境（IDE）<br>  Dev-C++功能简陋…不，应该是某种意义上的简洁，对新人不太友好但却实际上适合新手入门以及充当C&#x2F;C++的教学工具。</p>
<h2 id="Dev-C-的各个分支"><a href="#Dev-C-的各个分支" class="headerlink" title="Dev-C++的各个分支"></a>Dev-C++的各个分支</h2><p>  Dev-C++，作为一个开源项目，它也有着在大多数开源项目上常见的悲惨，却又幸运的命运。<br>  2000年左右，Bloodshed Software团队以构建一个轻量，免费，开源的C&#x2F;C++ IDE为宗旨，创建了Dev-C++项目。不过由于整个团队几乎是在用爱发电，到2005年时，Bloodshed以“失去开发动力”为由，宣布无限期暂停Dev-C++的更新，Dev-C++的版本号停滞在了4.9.9。<br>  但是当时的Dev-C++实在是太讨人喜欢了，在原团队停止开发后，无数的社区开发者们自发地扛起了Dev-C++的更新工作，其中最有名的当属Orwell团队。<br>  Orwell团队在2011年成功将Dev-C++的版本号推至5.x，在2016年发布了他们的最后一个版本——5.11。<br>  从2016年到2020年，只有一些个人维护的Dev-C++分支仍在更新，Dev-C++社区总体上停滞不前。<br>  但2020年7月，Embarcadero公司投入资金并以Orwell Dev-C++ 5.11为蓝本继续开发，这也就是我们即将接触的Embarcadero Dev-C++的来源。</p>
<h2 id="我为什么认为Dev-C-是一个好的C语言教具"><a href="#我为什么认为Dev-C-是一个好的C语言教具" class="headerlink" title="我为什么认为Dev-C++是一个好的C语言教具"></a>我为什么认为Dev-C++是一个好的C语言教具</h2><p>  众所周知，完事开头难，如果你让一个从未学习过编程的人一来就使用Visual Studio这样的工具，它多半还没有开始敲字就被一堆又一堆的按钮给吓住了。<br>  使用Dev-C++这样老旧的IDE有一个好处，就是它并不会像Visua Studio那样将编译链接的过程隐藏起来，也没有IntelliCode来掩盖你记不住关键字和函数的事实。Dev-C++将编译链接的理论模型简单套上一层自动化脚本，然后直接摆在使用者的面前，给人一种好像就是在用终端指令操纵gcc去编译程序的感觉，熟悉Dev-C++的操作流程以后，能较为方便地切换到Makefile以及CMake这样更加专业的构建工具上，我想这也是老一辈程序员们热爱它的原因，某种意义上它难以理解，某种意义上它也简单干净，它不为资本所追求的快速迭代而服务，它忠于技术本身，它属于程序员。</p>
<h1 id="Dev-C-的下载与安装"><a href="#Dev-C-的下载与安装" class="headerlink" title="Dev-C++的下载与安装"></a>Dev-C++的下载与安装</h1><h2 id="下载Dev-C-安装包"><a href="#下载Dev-C-安装包" class="headerlink" title="下载Dev-C++安装包"></a>下载Dev-C++安装包</h2><p>  作为名副其实的老开源项目，Orwell Dev-C++的仓库托管在<a target="_blank" rel="noopener" href="https://sourceforge.net/projects/orwelldevcpp/">Sourceforge</a>，而重生于2020年的Embarcadero Dev-C++则开源于<a target="_blank" rel="noopener" href="https://github.com/Embarcadero/Dev-Cpp">Github</a><br>  你可以在上述Github仓库页面找到Embarcadero Dev-C++的最新Release。截至本文完稿时的最新版本为6.3，附带的编译器为TDM-GCC，这也是下面我用到的版本。</p>
<h2 id="安装Dev-C"><a href="#安装Dev-C" class="headerlink" title="安装Dev-C++"></a>安装Dev-C++</h2><p>  <del>你不会拿到安装包了还不会装吧？</del><br>  <del>不会吧不会吧？</del><br>  Embarcadero Dev-C++的Github Release里应该同时包含了exe安装包和可绿色安装的压缩包，我的建议是使用后者，解压即用，双击devcpp.exe起飞。<br>  第一次启动Dev-C++时会要你选择语言和一些主题设置，我的建议是使用Visual Studio Dark配色以及Windows10图标，不包你喜欢但是保证不辣眼睛。</p>
<h1 id="Dev-C-的基本操作"><a href="#Dev-C-的基本操作" class="headerlink" title="Dev-C++的基本操作"></a>Dev-C++的基本操作</h1><h2 id="新建和打开一个工程"><a href="#新建和打开一个工程" class="headerlink" title="新建和打开一个工程"></a>新建和打开一个工程</h2><p>  和大多数IDE一样，在开始编码之前你得先创建一个项目，进入软件后点击左上角文件-&gt;新建-&gt;项目，然后选择你要创建的项目类型。<br>  这里我以控制台程序（Console Application）为例。<br>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/vYYOKO"><img src="https://s1.ax1x.com/2022/08/12/vYYOKO.png" alt="vYYOKO.png"></a><br>  点击确认后会需要你选择一个位置作为该项目的根目录，随后会在你选择的路径下创建一个项目文件，如下图。<br>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/vYt3sU"><img src="https://s1.ax1x.com/2022/08/12/vYt3sU.png" alt="vYt3sU.png"></a><br>  这实际上是一个文本文件，它记录了该项目的各种配置以及源文件路径，你可以使用任意文本编辑器来查看它的内容，比如我的：<br>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/vYtUiR"><img src="https://s1.ax1x.com/2022/08/12/vYtUiR.png" alt="vYtUiR.png"></a><br>  当你关闭Dev-C++后，只需要用Dev-C++打开该.dev文件即可再次打开该工程。<br>  最简单的操作流程就是把.dev文件拖到devcpp.exe上，就像这样…<br>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/vYtTeg"><img src="https://s1.ax1x.com/2022/08/12/vYtTeg.png" alt="vYtTeg.png"></a></p>
<h2 id="向工程中添加源文件和头文件"><a href="#向工程中添加源文件和头文件" class="headerlink" title="向工程中添加源文件和头文件"></a>向工程中添加源文件和头文件</h2><p>  你可以直接右键某个项目然后新建一个文本文件在里面<br>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/vYN0ts"><img src="https://s1.ax1x.com/2022/08/12/vYN0ts.png" alt="vYN0ts.png"></a><br>  新建文件的路径，名称还有后缀都由你自己决定，Dev-C++和后面的编译器都只靠文件后缀来判断是源文件还是头文件或者是其他的什么玩意儿。但关于路径我想说的是，Dev-C++甚至允许你把添加的文件丢在任何一个目录，但我建议不要把他们丢在项目的根目录外面。</p>
<p>  你还可以右键工程以后直接点击“New File”，和上面的差不多，但是你得先按Ctrl+S保存才能选择保存路径。<br>  你也许也注意到了，工程的右键菜单里有创建文件夹，我想说的是这个“文件夹”并不是实际文件结构中的文件夹，只是在Dev-C++中对源文件和头文件进行分组归类。</p>
<h1 id="编译你的工程"><a href="#编译你的工程" class="headerlink" title="编译你的工程"></a>编译你的工程</h1><p>  在项目下放列出的所有文件都会被加入到Dev-C++的构建系统中，此时点击运行选项卡中的编译选项即可。<br>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/vYdpm8"><img src="https://s1.ax1x.com/2022/08/12/vYdpm8.png" alt="vYdpm8.png"></a></p>
<h1 id="运行你的工程"><a href="#运行你的工程" class="headerlink" title="运行你的工程"></a>运行你的工程</h1><p>  再去看看上面所说的那个选项卡，你会发现里面有“运行”和“编译运行”这两个选项。<br>  和Visual Studio不一样，Dev-C++的“运行”就真的只是运行，不包含编译。<br>  也就是说，在运行之前，你得先把你的程序编译出来。（这一点同样适用于很多老旧的IDE，比如隔壁Code::Blocks）<br>  至于“编译运行”这个选项，其实就是字面意思，把两步合并在了一起，也就是一键开跑了，倒也还算方便。</p>
<h1 id="在Dev-C-中Debug"><a href="#在Dev-C-中Debug" class="headerlink" title="在Dev-C++中Debug"></a>在Dev-C++中Debug</h1><p>  Dev-C++的Debug功能实际上是调用gdb实现的，使用流程也无非就是常见的打断点-&gt;Debug运行，然后步进啥的，看一眼你们大概就都会了。<br>  对了，Dev-C++的断点是不会独立成一行的，而是和行号重叠，在编辑器里点一下行号就能打断点了。<br>  另外，开始Debug的按钮是“运行”选项卡里的“调试”，如下图所示。<br>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/vYBnnP"><img src="https://s1.ax1x.com/2022/08/12/vYBnnP.png" alt="vYBnnP.png"></a></p>
<h1 id="使用快捷键替代鼠标操纵"><a href="#使用快捷键替代鼠标操纵" class="headerlink" title="使用快捷键替代鼠标操纵"></a>使用快捷键替代鼠标操纵</h1><p>  说句大实话，这是提升你的生产效率的必要途径。在各个选项卡中你可以在找到各个功能对应的快捷键（写在右侧，比如调试的快捷键是F5），熟练后尽量使用那些快捷键，而不是慢吞吞地摸出鼠标然后到处点点点。</p>
<h1 id="Dev-C-其他的一些功能"><a href="#Dev-C-其他的一些功能" class="headerlink" title="Dev-C++其他的一些功能"></a>Dev-C++其他的一些功能</h1><h2 id="代码格式化工具"><a href="#代码格式化工具" class="headerlink" title="代码格式化工具"></a>代码格式化工具</h2><p>  Dev-C++集成了AStyle，可以快速按照某种代码风格来格式化你的代码。<br>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/vYDG5D"><img src="https://s1.ax1x.com/2022/08/12/vYDG5D.png" alt="vYDG5D.png"></a><br>  具体的格式化策略你可以点击“格式化选项”来修改。<br>  顺便一提：<br>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/vYDxZ6"><img src="https://s1.ax1x.com/2022/08/12/vYDxZ6.png" alt="vYDxZ6.png"></a><br>  好吧，只是抖个机灵。<br>  实际上我也并没有完全遵守Allman风格。</p>
<h2 id="添加编译选项"><a href="#添加编译选项" class="headerlink" title="添加编译选项"></a>添加编译选项</h2><p>  在“工具”选项卡里你可以找到“编译选项”，值得一提的是这里将编译指令和链接指令分开了。<br>  至于这里应该写些什么，你可能得先去了解一下gcc和ld，以后我可能会写一文介绍它们。</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>  至此，你应该以及能够使用Dev-C++进行基本的开发和调试了，剩下的就是学习C&#x2F;C++这两门语言本身，以及它们的生态了。<br>  作为（半个）过来人，相信我，在C++面前，起初你可能心情激动，满脑子“就这？”，但越是学到后面，你会愈发地痛不欲生。</p>
<h1 id="附：Dev-C-构建系统的实质"><a href="#附：Dev-C-构建系统的实质" class="headerlink" title="附：Dev-C++构建系统的实质"></a>附：Dev-C++构建系统的实质</h1><p>  其实如果你去看一眼创建的工程的目录就会发现，Dev-C++其实是调用的Makefile进行的项目构建。<br>  具体的Makefile脚本就是项目根目录下的“Makefile.win”。<br>  至于Makefile是什么以及有什么用，那就说来话长了，等我以后再写一文吧。<br>  但是要简单说说也行，Makefile提供了一套简单的系统来按需编译源文件然后链接，主要解决的就是编译问题，Makefile只会重新编译那些被修改了的源文件，而保留其他没有被修改的源文件的目标文件，大大减少了大型项目中重复的不必要编译，提高了项目整体的编译速度。<br>  当然Makefile也可以玩得很花，远远不止上述内容，不过那些就真的是另一文的内容了。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/408296605/answer/1534214395">知乎：如何评价Embarcadero Dev-C++? - JohnLu的回答</a><br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Dev-C++">百度百科：Dev-C++</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/12/%E4%BB%8EC%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%B0%83%E7%94%A8Python%E5%B9%B6%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/12/%E4%BB%8EC%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%B0%83%E7%94%A8Python%E5%B9%B6%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%B4%A2/" class="post-title-link" itemprop="url">从C程序中调用Python并返回值的初步探索</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-12 14:21:18" itemprop="dateCreated datePublished" datetime="2022-08-12T14:21:18+08:00">2022-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-13 11:29:33" itemprop="dateModified" datetime="2022-08-13T11:29:33+08:00">2022-08-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>  这是一篇翻新文档，最初写于2022&#x2F;1&#x2F;30，我对其内容几乎没有修改，亦未检查本文可靠性，请自行斟酌。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>  翻遍了谷歌百度发现一堆人Python3和Python2傻傻分不清，拿着Python2的函数写Python3的调用，API还是错的，简直是误人子弟，Python官方的API文档也没多大用。这里列出经过一上午的激战摸索出来的正确方案。<br>  C中Python3脚本的调用可以分为以下步骤：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>导入Python库</td>
<td>#include &lt;Python.h&gt;</td>
</tr>
<tr>
<td>初始化Python解释器</td>
<td>Py_Initialize();</td>
</tr>
<tr>
<td>设置模块路径（可选）</td>
<td>PyRunSimpleString(“import sys\nsys.path.append(‘.&#x2F;‘)”);</td>
</tr>
<tr>
<td>导入模块</td>
<td>PyImport_ImportModule(“mod_name”);</td>
</tr>
<tr>
<td>从模块中导入方法</td>
<td>PyObject_GetAttrString(Module,”func_name”);</td>
</tr>
<tr>
<td>创建将要导入方法的参数</td>
<td>Py_BuildValue(“(s)”,”str_arg”);</td>
</tr>
<tr>
<td>调用方法并处理参数</td>
<td>PyEval_CallObject(Method,Arg);</td>
</tr>
<tr>
<td>清理Python解释器</td>
<td>Py_Finalize();</td>
</tr>
</tbody></table>
<p>  Python是一门动态的脚本语言，在C API中也体现了这一点：C API中Python的一切数据类型和对象都是PyObject的“派生类”（但其实C中并没有class，虽然可以有OOP），可以使用PyObject的指针储存。</p>
<h1 id="使用列"><a href="#使用列" class="headerlink" title="使用列"></a>使用列</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Python.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Py_Initialize</span>();</span><br><span class="line">    <span class="built_in">PyRun_SimpleString</span>(<span class="string">&quot;import sys&quot;</span>);</span><br><span class="line">    <span class="built_in">PyRun_SimpleString</span>(<span class="string">&quot;sys.path.append(&#x27;./&#x27;)&quot;</span>);</span><br><span class="line">    <span class="comment">// 在C中导入指定py模块</span></span><br><span class="line">    PyObject* pyModule = <span class="built_in">PyImport_ImportModule</span>(<span class="string">&quot;my_test&quot;</span>);</span><br><span class="line">    <span class="comment">// 导入方法并调用</span></span><br><span class="line">    PyObject* pyMethod = <span class="built_in">PyObject_GetAttrString</span>(pModule,<span class="string">&quot;main&quot;</span>);</span><br><span class="line">    PyObject* pyReturn = <span class="built_in">PyEval_CallObject</span>(pMethod, <span class="built_in">Py_BuildValue</span>(<span class="string">&quot;(s)&quot;</span>,<span class="string">&quot;Hi PYTHON!&quot;</span>));</span><br><span class="line">    <span class="type">char</span>* buffer;</span><br><span class="line">    <span class="comment">// 将Python返回的str对象转为C可以使用的char*</span></span><br><span class="line">    <span class="built_in">PyArg_Parse</span>(send_back, <span class="string">&quot;s&quot;</span>, &amp;buffer);</span><br><span class="line">    <span class="comment">// 输出返回值</span></span><br><span class="line">    <span class="built_in">printf</span>(“%s”,buffer);</span><br><span class="line">    <span class="built_in">Py_Finalize</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="对C-封装Python模块的设想"><a href="#对C-封装Python模块的设想" class="headerlink" title="对C++封装Python模块的设想"></a>对C++封装Python模块的设想</h1><p>  综上，从一个Python模块中调用函数并接受返回值需要整整八（或者七？）步。是否可以用C++，在一个文件对应一个同名模块的前提下进行一个简单的封装以实现开箱即用？</p>
<h1 id="后日谈"><a href="#后日谈" class="headerlink" title="后日谈"></a>后日谈</h1><p>  原文到上面那里就已经没有了，关于那个封装，我确实有试过，但是现在有<a target="_blank" rel="noopener" href="https://github.com/pybind/pybind11">更好的选择</a>。<br>  另外，Boost库里也有对Python API的封装，但是，感觉不如pybind11。。。画质（x</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/12/cout%E4%B8%8Estringstream%E5%9C%A8%E7%BC%93%E5%86%B2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8A%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%AE%E8%B7%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/12/cout%E4%B8%8Estringstream%E5%9C%A8%E7%BC%93%E5%86%B2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8A%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%AE%E8%B7%9D/" class="post-title-link" itemprop="url">C++中std::cout 与 std::stringstream 在缓冲字符串上的性能差距</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-12 13:46:49 / 修改时间：14:18:27" itemprop="dateCreated datePublished" datetime="2022-08-12T13:46:49+08:00">2022-08-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>  这是一篇翻新文档，最初写于2022&#x2F;1&#x2F;30，现简单修改并重新发布。</p>
<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><table>
<thead>
<tr>
<th>项目</th>
<th>参数</th>
</tr>
</thead>
<tbody><tr>
<td>操作系统</td>
<td>Fedora Linux 35 (Kernel-5.15.16-200)</td>
</tr>
<tr>
<td>编译器</td>
<td>gcc 11.2.1 (Red Hat 11.2.1-7) 未开启优化</td>
</tr>
<tr>
<td>计时工具</td>
<td>time指令</td>
</tr>
</tbody></table>
<p>实验机器部分配置：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>参数</th>
</tr>
</thead>
<tbody><tr>
<td>CPU</td>
<td>Intel Core I5 - 4460</td>
</tr>
<tr>
<td>RAM</td>
<td>4G DDR3 1600Mhz（单通道）</td>
</tr>
</tbody></table>
<h1 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h1><h2 id="std-cout"><a href="#std-cout" class="headerlink" title="std::cout"></a>std::cout</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">114514</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;any str\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="std-cout-std-endl"><a href="#std-cout-std-endl" class="headerlink" title="std::cout + std::endl"></a>std::cout + std::endl</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">114514</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;any str&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="std-stringstream-std-cout"><a href="#std-stringstream-std-cout" class="headerlink" title="std::stringstream + std::cout"></a>std::stringstream + std::cout</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">114514</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ss &lt;&lt; <span class="string">&quot;any str\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ss.<span class="built_in">str</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><table>
<thead>
<tr>
<th>项目</th>
<th>第一次</th>
<th>第二次</th>
<th>第三次</th>
<th>平均</th>
</tr>
</thead>
<tbody><tr>
<td>std::cout</td>
<td>0.225</td>
<td>0.224</td>
<td>0.225</td>
<td>0.2247</td>
</tr>
<tr>
<td>std::cout + std::endl</td>
<td>0.228</td>
<td>0.222</td>
<td>0.221</td>
<td>0.2237</td>
</tr>
<tr>
<td>std::stringstream  + std::cout</td>
<td>0.076</td>
<td>0.071</td>
<td>0.069</td>
<td>0.0720</td>
</tr>
</tbody></table>
<p>  柱状图如下<br>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/vJr03j"><img src="https://s1.ax1x.com/2022/08/12/vJr03j.png" alt="vJr03j.png"></a><br>  <em>（注：std::ostringstream和std::istringstream因都是std::stringstream派生类不再讨论，且实验表明他们的速度基本没有差别。）</em></p>
<h1 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h1><p>  实验结果表明，在当前实验环境下，使用std::stringstream缓冲字符串，再用std::stringstream::str()将缓冲的字符串转至std::cout进行输出，较直接使用std::cout有明显的性能优势。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/12/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/12/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/" class="post-title-link" itemprop="url">十六进制与二进制之间的联系</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-12 13:35:38" itemprop="dateCreated datePublished" datetime="2022-08-12T13:35:38+08:00">2022-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-16 23:37:16" itemprop="dateModified" datetime="2022-09-16T23:37:16+08:00">2022-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>  这是一篇翻新文档，最初写于2022&#x2F;2&#x2F;1，现简单修改并重新发布。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>  首先，我们需要知道十六进制数是由 0 1 2 3 4 5 6 7 8 9 A B C D E F(大小写无关)任意排列所得的数，它们分别表示十进制中的0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15，没有16是因为到16时已经进一位了。</p>
<p>  我们已经知道二进制和十进制之间相互转换的方法，则通过上述对照关系，我们可以以十进制为桥梁，对二进制和十六进制进行相互的转化，例如：</p>
<table>
<thead>
<tr>
<th>十六进制</th>
<th>十进制</th>
<th>二进制</th>
</tr>
</thead>
<tbody><tr>
<td>C</td>
<td>12</td>
<td>1100</td>
</tr>
<tr>
<td>46</td>
<td>70</td>
<td>1000110</td>
</tr>
<tr>
<td>66CCFF</td>
<td>107794431</td>
<td>11001101100110011111111</td>
</tr>
</tbody></table>
<p>  上述方法原理简单，但多少有些难以计算，对此我们有一种更好的方法:<br>易得16&#x2F;2&#x3D;4，则只需要四位二进制数即可表示一个十六进制数，反之亦然。<br>  由此我们可以得出如下过程：<br>  有一二进制数0010 0001 0110 （空格只为了方便阅读）<br>  则每四位一读，读出三个四位的二进制数：0010，0001，0110<br>  四位二进制可以方便地直接转为十六进制，将上述内容转为十六进制得:2,1,6<br>  则上述二进制数的十六进制表达为2 1 6，即十六进制数216。</p>
<p>  另:由上述推理过程我们不难看出计算机程序设计中十六进制数大量使用的原因：用十六进制数表示的二进制数更短，适合人类阅读，同时也能快速地转换回二进制。（毕竟计算机里没有奇数位的二进制数不是吗？）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/12/%E4%BB%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%B0%E5%8D%81%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/12/%E4%BB%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%B0%E5%8D%81%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">从二进制到十进制的转换方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-12 13:26:14" itemprop="dateCreated datePublished" datetime="2022-08-12T13:26:14+08:00">2022-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-16 23:38:00" itemprop="dateModified" datetime="2022-09-16T23:38:00+08:00">2022-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>  这是一篇翻新文档，最初写于2022&#x2F;2&#x2F;1，现简单修改并重新发布。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>  先来看几个实例</p>
<table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
</tr>
</thead>
<tbody><tr>
<td>00000001</td>
<td>1</td>
</tr>
<tr>
<td>00000010</td>
<td>2</td>
</tr>
<tr>
<td>00000100</td>
<td>4</td>
</tr>
<tr>
<td>00001000</td>
<td>8</td>
</tr>
<tr>
<td>00010000</td>
<td>16</td>
</tr>
<tr>
<td>00100000</td>
<td>32</td>
</tr>
<tr>
<td>01000000</td>
<td>64</td>
</tr>
<tr>
<td>10000000</td>
<td>128</td>
</tr>
</tbody></table>
<p>  上表列举了一个八位二进制数（1字节）00000001按位左移的结果。<br>  由图易得：设一个二进制数00000001向左位移次数为x，则有将其转换为十进制的方程f(x)&#x3D;2∧(x-1)<br>  经检验，该结论正确，过程略。</p>
<p>  由上述结论我们不难推测，是否存在任意长度的任意二进制数，可以拆分为多个形如00…001向左位移得到的二进制数，再带入上述方程的结果之合为该二进制数的十进制值？</p>
<p>  经过验证，发现该假设成立，过程简要如下：</p>
<p>  例如：有一个二进制数000010100<br>  单独看1的位置，发现有两个1，分别位于第5和第3位。<br>  则将此二进制数拆分为两个二进制数：000010000和000000100。<br>  将此二者带入上述f（x），分别得解为2 ∧ 4 &#x3D; 16， 2 ∧ 2 &#x3D; 4<br>  两解相加为20</p>
<p>  经过检验，成立。</p>
<p>  综上所述，我们得到一种由二进制数转换为十进制数的快速方法：<br>  只看1的位置，对于每一个1，将自右数起到该1的位数的值（不包括该1所在位）作为2的幂得到多个中间值，再将所有中间值相加得到该二进制数的十进制值。</p>
<h1 id="后日谈"><a href="#后日谈" class="headerlink" title="后日谈"></a>后日谈</h1><p>  其实现在看来，二进制转十进制实际上就是一个等比数列求和，具体自己看吧。<br>  对了，高考之前我甚至真的遇到这样的题目了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/11/WSL2%E4%B8%8EWSLg%E7%9A%84%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/11/WSL2%E4%B8%8EWSLg%E7%9A%84%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">WSL2与WSLg的部署</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-11 22:04:01" itemprop="dateCreated datePublished" datetime="2022-08-11T22:04:01+08:00">2022-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-16 23:38:33" itemprop="dateModified" datetime="2022-09-16T23:38:33+08:00">2022-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>  今日拿到了新的笔记本，很是开心，但是又得从头配置一遍自己的开发环境了，很是难受。<br>  不过既然事已至此，就随着配置的步伐，顺便水一文吧！</p>
<h2 id="什么是WSL2和WSLg"><a href="#什么是WSL2和WSLg" class="headerlink" title="什么是WSL2和WSLg"></a>什么是WSL2和WSLg</h2><p>  其实我更建议你去翻<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/wsl/">微软的文档</a>。<br>  简单来说，WSL（Windwos下的Linux子系统）提供了一套内核级的翻译机制，能在Windows上翻译执行Linux的ELF格式程序。<br>  而WSL2则是微软妥协的结果，放弃了初代的翻译机制，转而投靠了日渐成熟的Hyper-V虚拟机（一个微软开发的内核级虚拟化平台）。<br>  WSL2实际上就是一个运行在Windows Hyper-V虚拟化平台上的Linux虚拟机，但是相比于直接在虚拟化软件中创建虚拟机，WSL2占用资源相对较少，且提供了对Windows资源管理器的部分集成。<br>  WSLg则是在WSL2的基础上增加了一套图像渲染系统，这套系统的Linux底层是Xorg（X11），通过Windows上dwm混成得到窗口。<br>  简而言之，WSLg能够让你在WSL2中运行绝大多数Linux GUI程序。</p>
<h2 id="本文适用条件"><a href="#本文适用条件" class="headerlink" title="本文适用条件"></a>本文适用条件</h2><p>  WSLg：我的环境是Windows11，Windows10印象中也是支持的。<br>  WSL2：Windows10与Windows11皆可。</p>
<h1 id="部署WSL2"><a href="#部署WSL2" class="headerlink" title="部署WSL2"></a>部署WSL2</h1><h2 id="开启相应的Windows功能"><a href="#开启相应的Windows功能" class="headerlink" title="开启相应的Windows功能"></a>开启相应的Windows功能</h2><p>  按Win键-&gt;点设置-&gt;点应用-&gt;往下翻-&gt;点更多Windows功能<br>  勾选 Windows虚拟机监控平台 | 适用于Windows的Linux子系统 | 虚拟机平台<br>  <del>（实际上，虚拟机监控平台大概是不必要的，但是为了兼容其他虚拟机，比如VMware，VirtualBox，还是开着吧）</del></p>
<h2 id="安装WSL2内核文件"><a href="#安装WSL2内核文件" class="headerlink" title="安装WSL2内核文件"></a>安装WSL2内核文件</h2><p>  尽管<a target="_blank" rel="noopener" href="https://github.com/microsoft/WSL2-Linux-Kernel">WSL2-Linux-Kernal项目</a>的Release早已实装5.15版本内核，但并没有提供相应版本的二进制文件。微软的WSL2文档也依然在提供5.10版本内核的链接。<br>  对于这方面，我的建议通常是使用尽可能新的内核，除非你是在配置一个生产环境。<br>  但这次情况特殊，除非你真的有能力编译一个Linux Kernel，那就老老实实用<a target="_blank" rel="noopener" href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">5.10</a>吧。</p>
<h2 id="设置WSL默认版本至WSL2"><a href="#设置WSL默认版本至WSL2" class="headerlink" title="设置WSL默认版本至WSL2"></a>设置WSL默认版本至WSL2</h2><p>  以管理员权限运行Windows Terminal（或者Windows10的管理员权限运行的PowerShell），运行如下指令<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-default-version 2</span><br></pre></td></tr></table></figure></p>
<h2 id="安装一个WSL2发行版"><a href="#安装一个WSL2发行版" class="headerlink" title="安装一个WSL2发行版"></a>安装一个WSL2发行版</h2><p>  最方便的做法是在微软商店中搜索然后一键安装，但这样你的WSL2会被安装在C盘里（User文件夹深处，具体太复杂，自己查吧），如果你不在乎那点空间占用，可以这样做。<br>  还有一种方法是下载发行版的appx安装包，然后手动安装，具体见下文。</p>
<h3 id="一键安装"><a href="#一键安装" class="headerlink" title="一键安装"></a>一键安装</h3><p>  打开微软商店，搜索你喜欢的发行版，一键安装，点击运行，输入用户名和密码，一切就大功告成了。<br>  下次想要进入WSL2可以直接打开Windows Terminal，使用此种安装方式，你所安装的WSL2发行版的选项卡会自动加入到Windows Terminal的备选终端中。</p>
<h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><p>  微软商店内的应用实际上都被打包为.appx安装包，你可以将其粗略地理解为Android的.apk。<br>  和apk类似的，appx实际上也是一个归档文件，你可以使用任意压缩软件打开它。<br>  如上所属，如果你能拿到某个WSL发行版的appx安装包，你可以将里面的内容解压到一个你认为合适的目录，这样，WSL2就能被安装到任意位置了。<br>  你可以在微软的文档里找到部分发行版appx安装包的下载直连，这里我搬运了一些。</p>
<p>  <a target="_blank" rel="noopener" href="https://aka.ms/wslubuntu2204">Ubuntu 22.04 LTS</a><br>  <a target="_blank" rel="noopener" href="https://aka.ms/wslubuntu2004arm">Ubuntu 20.04 ARM</a><br>  <a target="_blank" rel="noopener" href="https://aka.ms/wsl-debian-gnulinux">Debian</a><br>  <a target="_blank" rel="noopener" href="https://aka.ms/wsl-kali-linux-new">Kali</a><br>  <a target="_blank" rel="noopener" href="https://aka.ms/wsl-opensuse-tumbleweed">OpenSUSE Tumbleweed</a><br>  <a target="_blank" rel="noopener" href="https://github.com/WhitewaterFoundry/WSLFedoraRemix/releases/">Fedora Remix for WSL</a></p>
<p>  解压appx后点击相应的xxx.exe即可，我相信你应该找得到（<br>  不过，有的发行版会将多个架构的版本打包在同一个appx里，也就是套了个娃，找找就有了。</p>
<h2 id="编辑WSL2配置文件"><a href="#编辑WSL2配置文件" class="headerlink" title="编辑WSL2配置文件"></a>编辑WSL2配置文件</h2><p>  WSL2的配置文件不会自动创建，你需要在自己的User文件夹中新建一个叫“.wslconfig”的文件，注意只有后缀没有名字。<br>  用你最喜欢的文本编辑器打开它，在第一行写上“[wsl2]”，即可开始配置你的WSL2。<br>  这里我提供了一份带有注释的配置文件，仅供参考。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">memory=4GB                  #WSL2最大可使用多少内存，单位可为GB或MB</span><br><span class="line">swap=1GB                    #WSL2最大可用的交换空间，其实就是虚拟内存，单位同上</span><br><span class="line">processor=4                 #分配给WSl2多少个CPU核心（其实是线程）（似乎对Intel 12th大小核不起作用）</span><br><span class="line">localhostForwarding=true    #是否将WSL2的localhost覆盖到物理机的localhost</span><br></pre></td></tr></table></figure>
<p>  注意：当WSL2完全关闭并且等待一段时间后才能加载修改过的.wslconfig（详见下述文档中的“第 8 秒的规则”），不过你可以在PowerShell中使用指令“wsl –shutdown”来加快这个过程。<br>  其实你甚至能在.wslconfig中指定WSL2使用的内核镜像 ，根据这一特性你甚至能打包任何Linux发行版到WSl2，但我懒得写了。<br>  更多内容见<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/wsl/wsl-config">微软的WSL高级配置文档</a></p>
<h2 id="在WSL2中访问物理机的文件"><a href="#在WSL2中访问物理机的文件" class="headerlink" title="在WSL2中访问物理机的文件"></a>在WSL2中访问物理机的文件</h2><p>  <em>注：不同的发行版可能有不同的挂在策略，此处仅列出Debian与Ubuntu通用的方案。</em><br>  在WSL2启动时，物理机的各个磁盘会被自动挂载至&#x2F;mnt目录，根据盘符（但是是小写）即可进入物理机对应的磁盘。<br>  例如，我在WSL2（debian）中进入物理机的桌面文件夹，指令为：$cd &#x2F;mnt&#x2F;c&#x2F;Users&#x2F;iaksh&#x2F;Desktop<br>  实际上本地磁盘在WSL2中的挂载是通过网络实现的，这也是WSL2与物理机目录IO缓慢的原因。</p>
<h1 id="部署WSLg"><a href="#部署WSLg" class="headerlink" title="部署WSLg"></a>部署WSLg</h1><h2 id="有关本文时效性的警告"><a href="#有关本文时效性的警告" class="headerlink" title="有关本文时效性的警告"></a>有关本文时效性的警告</h2><p>  虽然Windows11和WSLg的推出都有一段时间了，但WSLg目前的安装方式总是让我感到奇怪。<br>  这样的安装方式说不定哪天就被微软吃掉了，所以当你看见这篇文章的时候，请明确本文所属有关WSLg的内容可能已经失效。</p>
<h2 id="在WSL2的基础上手动安装WSLg"><a href="#在WSL2的基础上手动安装WSLg" class="headerlink" title="在WSL2的基础上手动安装WSLg"></a>在WSL2的基础上手动安装WSLg</h2><p>  以管理员权限打开Windows Terminal（Windows10下以管理员权限打开PowerShell），在确保WSL2已经关闭的情况下输入指令“wsl –update”。<br>  经过漫长的更新后，你的WSL2内核应该已经支持WSLg了。<br>  此时你可以在WSL2里运行任意GUI程序（比如从你的包管理器下载一个热乎的GIMP然后运行），需要注意的是加载时间可能会略长（视配置而定），而且当某些程序占用全屏时，运行在WSL2上的X11将会崩溃，紧接着Linux GUI程序也会崩溃。（目前发现QQ截图会触发此BUG）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">IAKSH</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/IAKSH" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;IAKSH" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:askzrj21@163.com" title="E-Mail → mailto:askzrj21@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">IAKSH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
