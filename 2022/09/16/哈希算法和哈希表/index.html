<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"iaksh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前言这篇文章将会简单介绍几种常见的哈希算法，然后是C++或Java的标准库中哈希函数与哈希表的基本使用，最后将会提供一个使用C语言手搓FNV-1a算法的示例，以及使用它实现的哈希表。 这篇文章虽然内容不多，但前前后后，也是删删改改了好多天了，虽然内容还是不尽人意，但希望此文能为你提供一点帮助，不说理解哈希，至少能够使用吧。 不知道某位大佬会不会来看这篇文章，关于哈希表的部分我不是很拿得准，如果理解">
<meta property="og:type" content="article">
<meta property="og:title" content="哈希算法和哈希表">
<meta property="og:url" content="https://iaksh.github.io/2022/09/16/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/index.html">
<meta property="og:site_name" content="Hello world!">
<meta property="og:description" content="前言这篇文章将会简单介绍几种常见的哈希算法，然后是C++或Java的标准库中哈希函数与哈希表的基本使用，最后将会提供一个使用C语言手搓FNV-1a算法的示例，以及使用它实现的哈希表。 这篇文章虽然内容不多，但前前后后，也是删删改改了好多天了，虽然内容还是不尽人意，但希望此文能为你提供一点帮助，不说理解哈希，至少能够使用吧。 不知道某位大佬会不会来看这篇文章，关于哈希表的部分我不是很拿得准，如果理解">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-09-16T15:36:34.000Z">
<meta property="article:modified_time" content="2022-10-04T08:22:56.653Z">
<meta property="article:author" content="IAKSH">
<meta property="article:tag" content="C">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://iaksh.github.io/2022/09/16/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>哈希算法和哈希表 | Hello world!</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hello world!</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/09/16/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          哈希算法和哈希表
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-16 23:36:34" itemprop="dateCreated datePublished" datetime="2022-09-16T23:36:34+08:00">2022-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-04 16:22:56" itemprop="dateModified" datetime="2022-10-04T16:22:56+08:00">2022-10-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章将会简单介绍几种常见的哈希算法，然后是C++或Java的标准库中哈希函数与哈希表的基本使用，最后将会提供一个使用C语言手搓FNV-1a算法的示例，以及使用它实现的哈希表。</p>
<p>这篇文章虽然内容不多，但前前后后，也是删删改改了好多天了，虽然内容还是不尽人意，但希望此文能为你提供一点帮助，不说理解哈希，至少能够使用吧。</p>
<p>不知道某位大佬会不会来看这篇文章，关于哈希表的部分我不是很拿得准，如果理解有误，请帮我指出。</p>
<h1 id="什么是哈希算法（散列算法）"><a href="#什么是哈希算法（散列算法）" class="headerlink" title="什么是哈希算法（散列算法）"></a>什么是哈希算法（散列算法）</h1><blockquote>
<p><strong>散列函数</strong>（英语：Hash function）又称<strong>散列算法</strong>、<strong>哈希函数</strong>，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0" title="函数">函数</a>将数据打乱混合，重新创建一个叫做<strong>散列值</strong>（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8#cite_note-1">[1]</a>好的散列函数在输入域中很少出现<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%95%A3%E5%88%97%E5%86%B2%E7%AA%81&action=edit&redlink=1" title="散列冲突（页面不存在）">散列冲突</a>。在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E8%A1%A8" title="散列表">散列表</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86" title="数据处理">数据处理</a>中，不抑制冲突来区别数据，会使得<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%B0%E5%BD%95&action=edit&redlink=1" title="数据库记录（页面不存在）">数据库记录</a>更难找到。</p>
<p>如今，散列算法也被用来加密存在数据库中的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC" title="密码">密码</a>（password）字符串，由于散列算法所计算出来的<strong>散列值（Hash Value）</strong>具有<strong>不可逆</strong>（无法逆向演算回原本的数值）的性质，因此可有效的保护密码。</p>
<p>——Wikipedia</p>
</blockquote>
<p>我个人认为散列是一种数学思想，或者说是一种思维方式，能被应用到任意的方面。</p>
<p>简单的说，哈希算法是一套映射，向它输入不同的数据就能获得不同的结果，比如无论算几次都有hash(A) &#x3D; a恒成立,而不可能有hash(B) &#x3D; a（前提是没有碰撞），而且你没办法从结果逆推出原来的数据。</p>
<h1 id="哈希算法有什么应用场景"><a href="#哈希算法有什么应用场景" class="headerlink" title="哈希算法有什么应用场景"></a>哈希算法有什么应用场景</h1><ol>
<li><p>安全加密：基于哈希算法的输出值与原始数据唯一对应且不可逆向，哈希值散乱分布不可预测这两个特性，哈希算法可以被应用于密码存储，数据加密等安全领域。</p>
</li>
<li><p>唯一标识：哈希算法的输入值可以是任意长度，输出值与原始数据唯一对应且不可逆向，所以哈希算法能被应用于文件校验领域，作为一个文件的”指纹“，成为它的唯一标识。</p>
</li>
<li><p>数据校验：哈希值有”散列“特征，即便原始数据只进行了细微的修改，依然会导致哈希值产生巨大的变化。由此，在安全加密和唯一标识的基础上，哈希算法还能被应用于数据校验。</p>
</li>
<li><p>散列函数：散列函数（哈希函数）是哈希表的基础，也是其最关键的部分，它直接决定了哈希表中发生碰撞（冲突）的概率和哈希表的性能。</p>
</li>
<li><p>数据分片和分布式：通过类似哈希表的结构，我们可以将一次数据索拆分并下发至不同的机器执行，以此实现分布式网络，提高运行效率甚至是解决单机根本无法进行的操作。</p>
</li>
</ol>
<h1 id="什么是哈希碰撞（哈希冲突）"><a href="#什么是哈希碰撞（哈希冲突）" class="headerlink" title="什么是哈希碰撞（哈希冲突）"></a>什么是哈希碰撞（哈希冲突）</h1><p>前文提到了“哈希算法获取数据的唯一对应哈希值”，这实际上需要建立在没有“哈希碰撞”的基础上。在理想情况下，我们向哈希函数输入两串数据，所返回哈希值一定不相同，但实际上，这样的说法并不成立。当不同的数据经过某种哈希算法获得了同一个哈希值，我们就称这时发生了“哈希碰撞”，就像是坐标系中的两个本应不相交的函数，随着X值的延伸，突然“碰撞”了，产生了至少一个交点。</p>
<p>哈希碰撞一旦发生，所谓的“密码学价值”也就得大打折扣了，但对于大多数哈希算法而言，碰撞虽无法避免，却也是难以发生的，在有限的范围内，我们可以近似地认为，哈希函数不会发生碰撞。</p>
<p>尽管如此，哈希碰撞依然带来了巨大的安全隐患，这种隐患不只是你从互联网上下载的文件的校验问题，它涉及到操作系统，企业服务器网络，甚至是金融体系的安全。</p>
<p>当然，数学家们也不是吃素的，早期的一些哈希算法被爆出漏洞后，不断的有一些新的算法出现，这些新算法的安全性极高，在短期，甚至是一段比较长的时期内几乎不会出现安全问题。</p>
<h1 id="常见的哈希算法"><a href="#常见的哈希算法" class="headerlink" title="常见的哈希算法"></a>常见的哈希算法</h1><p>实际上，哈希函数应该分为加密哈希函数和非加密哈希函数</p>
<blockquote>
<p>Every cryptographic hash function is a hash function. But not every hash function is a cryptographic hash.</p>
<p>A cryptographic hash function aims to guarantee a number of security properties. Most importantly that it’s hard to find collisions or pre-images and that the output appears random. (There are a few more properties, and “hard” has well defined bounds in this context, but that’s not important here.)</p>
<p>Non cryptographic hash functions just try to avoid collisions for non malicious input. Some aim to detect accidental changes in data (CRCs), others try to put objects into different buckets in a hash table with as few collisions as possible.</p>
<p>In exchange for weaker guarantees they are typically (much) faster.</p>
<p>I’d still call MD5 a cryptographic hash function, since it aimed to provide security. But it’s broken, and thus no longer usable as a cryptographic hash. On the other hand when you have a non cryptographic hash function, you can’t really call it “broken”, since it never tried to be secure in the first place.</p>
<p><a target="_blank" rel="noopener" href="https://security.stackexchange.com/a/11841">https://security.stackexchange.com/a/11841</a></p>
</blockquote>
<p>简单地说，非加密哈希函数只要求能够防御基本的恶意攻击，比较简单快速，而加密哈希函数则为了实现较高的安全性，不可逆性以及更加难以预测的哈希值分布而变得复杂。</p>
<p>我没有对这两个分类进行进一步的讨论，想要了解更多可以访问上面的连接。</p>
<p><em>到底怎样才能算是”常见“呢？这个问题很难回答…但我再这里列出了wiki上提到的部分以及我在搜集资料时见到比较多的算法。</em></p>
<p><em>另外，wiki上关于SHA-256等函数的碰撞情况是”无“，这显然是无稽之谈…我将他们全部改成“近似无”了。</em></p>
<table>
<thead>
<tr>
<th>算法名</th>
<th>碰撞情况</th>
<th>简述</th>
</tr>
</thead>
<tbody><tr>
<td>HAVAL</td>
<td>有</td>
<td>比较现代化的哈希函数，哈希值长度可为256&#x2F;224&#x2F;192&#x2F;160&#x2F;128bit</td>
</tr>
<tr>
<td>MD2</td>
<td>大多数</td>
<td>诞生于1989年，哈希值长度固定为128bit，“MD”意为“Message Digest”，由于自身设计缺陷，MD2于2009年被证明“容易受到攻击”，并被OpenSSL等项目禁用。</td>
</tr>
<tr>
<td>MD4</td>
<td>有</td>
<td>诞生于1990年的麻省理工学院，哈希值长度固定为128bit，对后世的算法（如MD5，SHA系以及RIPEMD）有长远的影响，其变种算法”eD2k Hash“至今仍被广泛用于eDonkey网络的eD2k链接中。</td>
</tr>
<tr>
<td>MD5</td>
<td>有</td>
<td>公开于1992年，其哈希值长度固定为128bit，用于取代MD4算法，曾盛极一时，但先后在1996和2004被证明安全性堪忧，此后MD5被广泛认为并不适用于安全性认证。</td>
</tr>
<tr>
<td>PANAMA</td>
<td>有</td>
<td>公开于1998年，哈希值长度固定为256bit，密码性能良好，但先后在2001于2007年被证明安全性不足，后基本被SHA-3取代。</td>
</tr>
<tr>
<td>RadioGatún</td>
<td>近似无</td>
<td>PANAMA的一个变体，哈希值长度任意，公开于2006年。</td>
</tr>
<tr>
<td>RIPEMD</td>
<td>有</td>
<td>公开于1996年，是一个来自比利时鲁汶大学的研究小组的成果，以MD4为基础，但与SHA-1更类似。</td>
</tr>
<tr>
<td>RIPEMD-128&#x2F;256</td>
<td>近似无</td>
<td>RIPEMD算法的一个变种，虽然128bit的哈希值长度相较于原版并没有进步，但RIPEMD-128解决了哈希碰撞问题。另外，256bit的版本只在128bit版本（非原版）的基础上修改了初始参数和s-box，两者的强度理论上是没有区别的。</td>
</tr>
<tr>
<td>RIPEMD-160&#x2F;320</td>
<td>近似无</td>
<td>RIPEMD算法的又一个变种，相较于RIPEMD-128拥有更高的安全等级。同样的，320bit的版本也只是在160bit版本的基础上修改了初始参数和s-box，两者的强度理论上没有区别。</td>
</tr>
<tr>
<td>SHA-0</td>
<td>有</td>
<td>SHA家族的初代，SHA全写为”Secure Hash Algorithm”，由……美国国安局（NSA）设计，然后由美国国家标准与技术研究院（NIST）于1993年发布，但发布后又被NSA突然撤回。</td>
</tr>
<tr>
<td>SHA-1</td>
<td>有缺陷</td>
<td>MD5的继任者，发布于1995年，还是NSA设计，NIST发布，其哈希值长度固定为160bit。该算法于2005年被证明不够安全，2010年以来，越来越多的组织建议使用SHA-2或SHA-3替代SHA-1，但时至今日，SHA-1依然没用被完全弃用，尽管针对它的攻击手段早在2020年就已经成熟了。</td>
</tr>
<tr>
<td>SHA-256&#x2F;224</td>
<td>近似无</td>
<td>SHA-2的一部分，还是NSA，还是NIST。SHA-2发布于2001年，用于替代羸弱的SHA-1，包括6种算法标准：SHA-224，SHA-256（某种意义上的“明星”，是比特币使用的算法），SHA-384，SHA-512，SHA-512&#x2F;224，SHA-512&#x2F;256。就目前而言，SHA-2在理论上是安全的，它的碰撞可能性基本可以被看做是0。</td>
</tr>
<tr>
<td>SHA-512&#x2F;384</td>
<td>近似无</td>
<td>同上。</td>
</tr>
<tr>
<td>Tiger（2）-192&#x2F;160&#x2F;128</td>
<td>近似无</td>
<td>前身是诞生于1995年的Tiger算法，曾经有望纳入OpenPGP标准，但最后败给了RIPEMD-160算法。</td>
</tr>
<tr>
<td>WHIRLPOOL</td>
<td>近似无</td>
<td>公布于2000年，现已被国际标准化组织（ISO）和国际电工委员会（IEC）采用，做为ISO&#x2F;IEC 10118-3国际标准的一部分。其作者曾对外宣布自己”没有（也永远不会）申请专利“，该算可以免费地用于任何目的。</td>
</tr>
<tr>
<td>FNV-1a&#x2F;FNV-1</td>
<td>有</td>
<td>FNV算法诞生于1991年，其名称由三位设计者的名字拼接而成，该算法在保证快速的同时将冲突率限制在了相对合理的区间内，支持从32bit到1024bit的多种长度的哈希值输出，且其哈希值高度分散，非常适合处理网址，文本，文件名，IP地址等字符串。其最早版本FNV-0已被抛弃，更新的FNV-1和FNV-1a只在异或和乘法这两种运算的顺序上有差别。</td>
</tr>
</tbody></table>
<h1 id="C-和Java中预置的哈希函数和哈希表"><a href="#C-和Java中预置的哈希函数和哈希表" class="headerlink" title="C++和Java中预置的哈希函数和哈希表"></a>C++和Java中预置的哈希函数和哈希表</h1><ol>
<li>C++</li>
</ol>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ISO C++ 11标准及以后，标准库中提供了一个 std::hash&lt;T&gt;，返回参数的哈希值</span></span><br><span class="line"><span class="comment">// std::hash&lt;T&gt; 所使用的哈希算法是由具体编译器实现所决定的</span></span><br><span class="line"><span class="comment">// 对于老旧的编译器，std::hash&lt;T&gt; 所使用的算法很可能是已经被破解，不再安全的</span></span><br><span class="line"><span class="comment">// 下面是 std::hash&lt;T&gt; 的一个使用列，打印字符串“Hello world!“的哈希值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hashTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">    std::hash&lt;std::string&gt; hashFunction;</span><br><span class="line">    <span class="type">size_t</span> hashValue = <span class="built_in">hashFunction</span>(str);</span><br><span class="line">    std::cout &lt;&lt; hashValue &lt;&lt; std;:endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还有两个键值对数据结构，分别是 std::map&lt;T,T&gt; 和 std::unordered_map&lt;T,T&gt;</span></span><br><span class="line"><span class="comment">// 前者的内部存储方式为平衡二叉查找树（比如红黑树），后者是真正的哈希表</span></span><br><span class="line"><span class="comment">// std::map</span></span><br><span class="line">map&lt;std::string,<span class="type">int</span>&gt; nameAgeMap =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">&quot;Hatsune Miku&quot;</span>,<span class="number">15</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;ZUN&quot;</span>,<span class="number">45</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::map 的插入，如果下标不存在，则新建，若存在则修改。</span></span><br><span class="line">nameAgeMap[<span class="string">&quot;Linus&quot;</span>] = <span class="number">52</span>;</span><br><span class="line"><span class="comment">// 上述语法与下式等价</span></span><br><span class="line">nameAgeMap.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;std::string,<span class="type">int</span>&gt;(<span class="string">&quot;Linus&quot;</span>,<span class="number">52</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::map 的取值</span></span><br><span class="line"><span class="keyword">auto</span> buffer0 = nameAgeMap[<span class="string">&quot;Linus&quot;</span>];</span><br><span class="line"><span class="comment">// 也可以这样写</span></span><br><span class="line"><span class="keyword">auto</span> buffer1 = nameAgeMap.<span class="built_in">at</span>(<span class="string">&quot;Linus&quot;</span>);</span><br><span class="line"><span class="comment">// 需要注意的是，map.at() 只会尝试读取，若找不到则报错</span></span><br><span class="line"><span class="comment">// 而map[]找不到则会创建，只是值未设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// std::map 的查找</span></span><br><span class="line"><span class="keyword">auto</span> iter = nameAgeMap.<span class="built_in">find</span>(<span class="string">&quot;Linus&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(ite == nameAgeMap.<span class="built_in">end</span>()) <span class="built_in">abort</span>();</span><br><span class="line"><span class="keyword">auto</span> value = iter-&gt;second;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::map 的遍历</span></span><br><span class="line"><span class="comment">// 作为STL的一部分，std::map提供了迭代器，可供迭代器循环或增强for使用。</span></span><br><span class="line"><span class="comment">// 迭代器语法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> item = nameAgeMap.<span class="built_in">begin</span>();item != nameAgeMap.<span class="built_in">end</span>();item++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 增强for</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; item : nameAgeMap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::map 的清除</span></span><br><span class="line"><span class="comment">// 通常情况下使用 map.clear() 就好</span></span><br><span class="line">nameAgeMap.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 至于 std::unordered_map，与 std::map 的接口都是一样的</span></span><br><span class="line"><span class="comment">// 两者只在内部实现有区别</span></span><br><span class="line"><span class="comment">// 通常情况下，std::map 内存使用更少，而 std::unordered_map 查找更快 </span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Java</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java标准库中提供了一些常用的哈希算法（如MD系和SHA系），并且统一了接口</span></span><br><span class="line"><span class="keyword">import</span> java.math.MessageDigest;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 此处示例使用了MD5算法，修改该处的字符串即可切换算法</span></span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        <span class="comment">// 下述代码向哈希算法连续输入值，实际上等于输入&quot;HelloWorld&quot;</span></span><br><span class="line">        md.update(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        md.update(<span class="string">&quot;World&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取UTF-8编码的&quot;HelloWorld&quot;的哈希值</span></span><br><span class="line">        <span class="type">byte</span>[] result = md.digest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String类实际上提供了一个快速的哈希函数</span></span><br><span class="line"><span class="comment">// 我没有查到String.hashCode()所使用的具体哈希算法，还望各位相告</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringFastHash</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;The hash code is:&quot;</span> + str.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java标准库中提供了两个哈希表：Hashtable和HashMap</span></span><br><span class="line"><span class="comment">// 两者都实现了Map接口</span></span><br><span class="line"><span class="comment">// 值得一提的区别是HashMap不能线程同步且键值可为null，Hashtable反之</span></span><br><span class="line"><span class="comment">// 其余的虽然也有区别，但是相差不大，只需要记得HashMap单线程里比另一者快就是</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String,Integer&gt; ages = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;();</span><br><span class="line">        <span class="comment">// 添加键值对示例</span></span><br><span class="line">        ages.put(<span class="string">&quot;Hatsune Miku&quot;</span>,<span class="number">15</span>);</span><br><span class="line">        ages.put(<span class="string">&quot;ZUN&quot;</span>,<span class="number">45</span>);</span><br><span class="line">        <span class="comment">// 访问元素示例</span></span><br><span class="line">        System.out.println(ages.get(<span class="string">&quot;ZUN&quot;</span>));</span><br><span class="line">        <span class="comment">// 删除元素示例</span></span><br><span class="line">        ages.remove(<span class="string">&quot;ZUN&quot;</span>);</span><br><span class="line">        <span class="comment">// 清空元素示例</span></span><br><span class="line">        ages.clear();</span><br><span class="line">        <span class="comment">// 计算元素数量示例</span></span><br><span class="line">        System.out.println(ages.size());</span><br><span class="line">        <span class="comment">// 迭代键</span></span><br><span class="line">        <span class="keyword">for</span>(String name: ages.values()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> age: ages.keySet()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其余类方法略，请自行查表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 至于Hashtable，大体接口也与HashMap类似，略</span></span><br></pre></td></tr></table></figure>
<h1 id="使用C语言搓一个简单的哈希算法"><a href="#使用C语言搓一个简单的哈希算法" class="headerlink" title="使用C语言搓一个简单的哈希算法"></a>使用C语言搓一个简单的哈希算法</h1><p>这里用的是FNV-1a算法（32bit），真的很简单。</p>
<p>FNV-1a属于非加密哈希函数，支持32bit&#x2F;64bit&#x2F;128bit&#x2F;256bit&#x2F;512bit&#x2F;1024bit的输出，根据输出长度的不同，其使用的常量不同，而算法不变。</p>
<p>wiki上有这样一段描述FNV-1a的伪代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">algorithm fnv-1a is</span><br><span class="line">    hash := FNV_offset_basis</span><br><span class="line"></span><br><span class="line">    for each byte_of_data to be hashed do</span><br><span class="line">        hash := hash XOR byte_of_data</span><br><span class="line">        hash := hash × FNV_prime</span><br><span class="line"></span><br><span class="line">    return hash</span><br></pre></td></tr></table></figure>

<p>可以看出这个算法非常简单，将初始哈希值循环进行乘法与异或运算即可得到哈希值。</p>
<p>查表可知，输出32bit的FNV-1a算法使用的两个常量FNV_offset_basi与FNV_prime分别有如下取值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> HASH_OFFSET_BASIS_32 = <span class="number">0x811C9DC5</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> FNV_PRIME_32         = <span class="number">16777619</span>;</span><br></pre></td></tr></table></figure>

<p>然后根据伪代码编写循环即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> hash = HASH_OFFSET_BASIS_32;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(data); i++)</span><br><span class="line">&#123;</span><br><span class="line">    hash ^= data[i];</span><br><span class="line">    hash *= FNV_PRIME_32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">fnv1a_32</span><span class="params">(<span class="type">char</span>* data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// FNV-1a算法根据输出位数不同，各常量的值不同，此处为输出32bit的版本</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> HASH_OFFSET_BASIS_32 = <span class="number">0x811C9DC5</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> FNV_PRIME_32         = <span class="number">16777619</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> hash = HASH_OFFSET_BASIS_32;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(data); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        hash ^= data[i];</span><br><span class="line">        hash *= FNV_PRIME_32;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用C语言搓一个简单的哈希表"><a href="#使用C语言搓一个简单的哈希表" class="headerlink" title="使用C语言搓一个简单的哈希表"></a>使用C语言搓一个简单的哈希表</h1><p>哈希表（Hashmap）是一种容器，实际上更像是一种加强版的数组，只不过数组是用数字下标映射地址，而哈希表通过哈希函数。</p>
<p>你可能听不懂，我们先来回顾一下传统的C-Style数组，是通过头指针+偏移量实现的，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nums[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// 下述两段语句等价</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,nums[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*nums);</span><br><span class="line"><span class="comment">// 下述两段语句等价</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,nums[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">// 头指针nums + 偏移量2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(nums + <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>这种方法简单粗暴但十分有效，无论数组中有多少个元素，索引总是一步就完成的（只需要按特定量偏移头指针），时间复杂度恒为O(1)。</p>
<p>假如我们需要建立一个数据结构，用于储存书名和对应的价格，按照上述思路可以这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">float</span> price;</span><br><span class="line">&#125; Book;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BOOK_COUNT 10;</span></span><br><span class="line">Book books[MAX_BOOK_COUNT]</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化books</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initializeBooks</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Book* book;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAX_BOOK_COUNT;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        book = books + i;</span><br><span class="line">        book-&gt;price = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来不错，我们优雅地将书名和价格封装到了一个数据结构里，然后创建了他们的数组，一切看起来都很美好，只不过索引的方式有些许…弱智。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录一本书的价格</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addBook</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">float</span> price)</span></span><br><span class="line">&#123;</span><br><span class="line">    books[count].price = price;</span><br><span class="line">    <span class="built_in">strcpy</span>(books[count].name,name);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一本书的价格</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">getPrice</span><span class="params">(<span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line">    Book* book;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAX_BOOK_COUNT;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        book = books + i;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(name,book-&gt;name) == <span class="number">0</span>) <span class="keyword">return</span> book-&gt;price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个获取价格的操作的时间复杂度是O(n)，当BOOK_COUNT变大，耗时会线性增加。</p>
<p>想象一下你想要找到一本书的价格，然后翻遍了整个图书馆。</p>
<p>但你有没有想过，如果你有一个机器人，当你告诉它你要找的书的名字，它就会立即告诉你书的位置，于是你就能快速找到那本书的价格了。</p>
<p>像这样的带有”机器人“的图书馆，我们也许可以叫它，哈希图书馆。</p>
<p>这就是哈希结构，所谓的”机器人“，就是哈希函数。</p>
<p>来试试看吧。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BOOK_COUNT 10;</span></span><br><span class="line"><span class="comment">// 哈希表依然使用数组储存数据，和传统数组结构相比，只改变了索引方式</span></span><br><span class="line"><span class="type">float</span> bookPriceHashmap[MAX_BOOK_COUNT];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initializeBooksHashmap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAX_BOOK_COUNT;i++) bookPriceHashmap[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希函数，此处使用之前的FNV-1a算法+取余法以限定值域</span></span><br><span class="line"><span class="comment">// 虽然简单，但这样做会导致哈希碰撞（哈希冲突）的可能性增加</span></span><br><span class="line"><span class="comment">// 想要保证足够低的碰撞几率，就得提高数组容量，使用更多内存</span></span><br><span class="line"><span class="comment">// 可是哈希表的本质就是用内存换时间，不是吗？</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> fnv1a_32(str) % MAX_BOOK_COUNT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录一本书的价格</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addBook</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">float</span> price)</span></span><br><span class="line">&#123;</span><br><span class="line">    bookPriceHashmap[hash(name)] = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一本书的价格</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">getPrice</span><span class="params">(<span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> bookPriceHashmap[hash(name)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，索引过程中仅仅在计算哈希时进入了循环，两个操作的时间复杂度都是O(1)，基本只需要考虑哈希算法的耗时，而获得哈希值后真正的索引耗时基本可以忽略不计。</p>
<p>上述哈希表的完整测试代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">fnv1a_32</span><span class="params">(<span class="type">char</span>* data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// FNV-1a算法根据输出位数不同，各常量的值不同，此处为输出32bit的版本</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> HASH_OFFSET_BASIS_32 = <span class="number">0x811C9DC5</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> FNV_PRIME_32         = <span class="number">16777619</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> hash = HASH_OFFSET_BASIS_32;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(data); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        hash ^= data[i];</span><br><span class="line">        hash *= FNV_PRIME_32;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BOOK_COUNT 10</span></span><br><span class="line"><span class="type">float</span> bookPriceHashmap[MAX_BOOK_COUNT];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initializeBooksHashmap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAX_BOOK_COUNT;i++) bookPriceHashmap[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> fnv1a_32(str) % MAX_BOOK_COUNT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addBook</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">float</span> price)</span></span><br><span class="line">&#123;</span><br><span class="line">    bookPriceHashmap[hash(name)] = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一本书的价格</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">getPrice</span><span class="params">(<span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> bookPriceHashmap[hash(name)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    addBook(<span class="string">&quot;三体1&quot;</span>, <span class="number">1145.14f</span>);</span><br><span class="line">    addBook(<span class="string">&quot;三体2&quot;</span>, <span class="number">19198.10f</span>);</span><br><span class="line">    addBook(<span class="string">&quot;The Selfish Gene&quot;</span>, <span class="number">99.61f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The price of 三体1 is %.2f\n&quot;</span>,getPrice(<span class="string">&quot;三体1&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The price of 三体2 is %.2f\n&quot;</span>,getPrice(<span class="string">&quot;三体2&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The price of The Selfish Gene is %.2f\n&quot;</span>,getPrice(<span class="string">&quot;The Selfish Gene&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以试试减小 MAX_BOOK_COUNT，然后添加更多的书本，感受一下哈希碰撞。</p>
<p>另外，哈希表其实是在用空间换取时间，在保证较小的碰撞概率的前提下，储存同样多元素的哈希表所占用的内存空间要明显大于数组。你可以编译并Debug上面的代码，查看 bookPriceHashmap 的内存，被修改过的非0数字散乱地分布在哈希表的内存片段中，这也是为什么哈希被称为”散列“。</p>
<p>不过话又说回来，除非是在搞嵌入式，有谁会在意那点内存呢？</p>
<h1 id="哈希表与数组的性能对比"><a href="#哈希表与数组的性能对比" class="headerlink" title="哈希表与数组的性能对比"></a>哈希表与数组的性能对比</h1><p>将上述代码的 MAX_BOOK_COUNT 修改为 30000000，向容器中填充 MAX_BOOK_COUNT&#x2F;4 个元素，然后分别测试哈希表与数组索引一个插入于 MAX_BOOK_COUNT&#x2F;8 位置的值，实验代码和结果如下。</p>
<ol>
<li>哈希表</li>
</ol>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">fnv1a_32</span><span class="params">(<span class="type">char</span>* data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// FNV-1a算法根据输出位数不同，各常量的值不同，此处为输出32bit的版本</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> HASH_OFFSET_BASIS_32 = <span class="number">0x811C9DC5</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> FNV_PRIME_32         = <span class="number">16777619</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> hash = HASH_OFFSET_BASIS_32;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(data); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        hash ^= data[i];</span><br><span class="line">        hash *= FNV_PRIME_32;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BOOK_COUNT 30000000</span></span><br><span class="line"><span class="type">float</span> bookPriceHashmap[MAX_BOOK_COUNT];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initializeBooksHashmap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAX_BOOK_COUNT;i++) bookPriceHashmap[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> fnv1a_32(str) % MAX_BOOK_COUNT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addBook</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">float</span> price)</span></span><br><span class="line">&#123;</span><br><span class="line">    bookPriceHashmap[hash(name)] = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一本书的价格</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">getPrice</span><span class="params">(<span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> bookPriceHashmap[hash(name)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">5</span>] = <span class="string">&quot;3体1&quot;</span>;</span><br><span class="line">    <span class="type">float</span> price = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAX_BOOK_COUNT / <span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == MAX_BOOK_COUNT / <span class="number">8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            addBook(<span class="string">&quot;C为什么是神&quot;</span>, <span class="number">114.51f</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++) name[j] += <span class="number">1</span>;</span><br><span class="line">        addBook(name, ++price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">clock_t</span> begin,end;</span><br><span class="line">    begin=clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;《C为什么是神》的价格是: %.2f\n&quot;</span>,getPrice(<span class="string">&quot;C为什么是神&quot;</span>));</span><br><span class="line">    end=clock();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>,(<span class="type">double</span>)(end-begin)/CLOCKS_PER_SEC);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>数组</li>
</ol>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">float</span> price;</span><br><span class="line">&#125; Book;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BOOK_COUNT 30000000</span></span><br><span class="line">Book books[MAX_BOOK_COUNT];</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化books</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initializeBooks</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Book* book;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAX_BOOK_COUNT;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        book = books + i;</span><br><span class="line">        book-&gt;price = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录一本书的价格</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addBook</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">float</span> price)</span></span><br><span class="line">&#123;</span><br><span class="line">    books[count].price = price;</span><br><span class="line">    <span class="built_in">strcpy</span>(books[count].name,name);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一本书的价格</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">getPrice</span><span class="params">(<span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line">    Book* book;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAX_BOOK_COUNT;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        book = books + i;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(name,book-&gt;name) == <span class="number">0</span>) <span class="keyword">return</span> book-&gt;price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">5</span>] = <span class="string">&quot;3体1&quot;</span>;</span><br><span class="line">    <span class="type">float</span> price = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; MAX_BOOK_COUNT / <span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == MAX_BOOK_COUNT / <span class="number">8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            addBook(<span class="string">&quot;C为什么是神&quot;</span>, <span class="number">114.51f</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++) name[j] += <span class="number">1</span>;</span><br><span class="line">        addBook(name, ++price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">clock_t</span> begin,end;</span><br><span class="line">    begin=clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;《C为什么是神》的价格是: %.2f\n&quot;</span>,getPrice(<span class="string">&quot;C为什么是神&quot;</span>));</span><br><span class="line">    end=clock();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>,(<span class="type">double</span>)(end-begin)/CLOCKS_PER_SEC);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>结果</li>
</ol>
<p>  使用Linux中的time命令计时，有如下结果</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>第一次</th>
<th>第二次</th>
<th>第三次</th>
<th>第四次</th>
<th>平均</th>
</tr>
</thead>
<tbody><tr>
<td>哈希表</td>
<td>0.000075</td>
<td>0.000065</td>
<td>0.000075</td>
<td>0.000074</td>
<td>0.00007225</td>
</tr>
<tr>
<td>数组</td>
<td>0.010207</td>
<td>0.010820</td>
<td>0.011146</td>
<td>0.011140</td>
<td>0.01082825</td>
</tr>
</tbody></table>
<p>  由此我们得到一个恐怖的结果，在该项测试中，哈希表的索引速度大约是数组的150倍，且随着 MAX_BOOK_COUNT 的增加，差距还会继续增大。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">散列函数 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304227729113121">哈希算法 - 廖雪峰的官方网站</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43935927/article/details/109126787">【必备算法】哈希算法：七种应用及场景示例_A minor的博客-CSDN博客_哈希算法简单举例</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/97763484">哈希算法及其应用场景 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-1a_hash">Fowler–Noll–Vo hash function - Wikipedia</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/huangkangying/article/details/8748537">常用Hash算法(C语言实现)_huangkangying的博客-CSDN博客_hash函数c语言实现</a></p>
<p><a target="_blank" rel="noopener" href="https://security.stackexchange.com/a/11841">https://security.stackexchange.com/a/11841</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C</a>
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/09/07/%E5%A6%82%E4%BD%95%E7%9C%8B%E6%87%82%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84big-O%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="prev" title="如何看懂时间复杂度的big-O表达式">
      <i class="fa fa-chevron-left"></i> 如何看懂时间复杂度的big-O表达式
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/10/04/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/" rel="next" title="快慢指针算法">
      快慢指针算法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%EF%BC%88%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">什么是哈希算法（散列算法）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.</span> <span class="nav-text">哈希算法有什么应用场景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E%EF%BC%88%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">什么是哈希碰撞（哈希冲突）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">常见的哈希算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E5%92%8CJava%E4%B8%AD%E9%A2%84%E7%BD%AE%E7%9A%84%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">6.</span> <span class="nav-text">C++和Java中预置的哈希函数和哈希表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8C%E8%AF%AD%E8%A8%80%E6%90%93%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">使用C语言搓一个简单的哈希算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8C%E8%AF%AD%E8%A8%80%E6%90%93%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">8.</span> <span class="nav-text">使用C语言搓一个简单的哈希表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="nav-number">9.</span> <span class="nav-text">哈希表与数组的性能对比</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">10.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">IAKSH</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/IAKSH" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;IAKSH" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:askzrj21@163.com" title="E-Mail → mailto:askzrj21@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">IAKSH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
